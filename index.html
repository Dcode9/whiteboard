<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minimalist Whiteboard</title>
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/Dcode9/whiteboard/dfcc6b7600fe1bf56dd763ea9715e9ad5363c227/WebBoard.png?v=2">
    
    <!-- GLOBAL ERROR HANDLER: Displays errors on screen to help debug blank deployments -->
    <script>
        window.onerror = function(msg, url, line, col, error) {
            var errorBox = document.getElementById('global-error-box');
            if (errorBox) {
                errorBox.style.display = 'block';
                errorBox.innerHTML += '<div><strong>Error:</strong> ' + msg + '<br><small>' + url + ':' + line + '</small></div><hr style="margin:5px 0;border-color:rgba(255,255,255,0.3)">';
            }
            console.error("Global Error:", msg, error);
            // Hide loading screen if error occurs so we can see the error
            var loader = document.getElementById('app-loading');
            if(loader) loader.style.display = 'none';
            return false;
        };
    </script>

    <!-- CRITICAL CSS: Inline styles for Loading Screen & Error Box (No Tailwind Dependency) -->
    <style>
        /* Spinner Animation */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Loading Overlay - Pure CSS to ensure it renders before external scripts */
        #app-loading {
            position: fixed;
            inset: 0;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #f3f4f6;
            z-index: 2147483647; /* Max Z-Index */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: sans-serif;
            color: #4b5563;
            transition: opacity 0.3s ease-out;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e5e7eb; /* Light grey */
            border-top: 4px solid #3b82f6; /* Blue */
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        /* Error Box Style */
        #global-error-box {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #ef4444;
            color: white;
            padding: 1rem;
            z-index: 2147483648; /* Above loading screen */
            font-family: monospace;
            font-size: 14px;
            max-height: 50vh;
            overflow: auto;
            border-bottom: 2px solid #7f1d1d;
        }
    </style>

    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Check if Tailwind loaded
        window.onload = function() {
            if (!window.tailwind) {
                console.warn("Tailwind CSS failed to load via CDN.");
            }
        }
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        }
    </script>
    
    <style>
        /* Basic styles for a smooth experience */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overscroll-behavior: none; /* Prevents pull-to-refresh */
            background-color: #f3f4f6; /* Fallback bg */
        }
        
        /* View Management */
        .view {
            display: none;
            width: 100%;
            height: 100%;
        }
        
        .view.active {
            display: block;
        }
        
        /* Homepage styles */
        #homepage-view {
            overflow-y: auto;
            background-color: #f3f4f6;
        }
        
        /* Whiteboard view */
        #whiteboard-view {
            overflow: hidden;
        }
        
        /* Header styles */
        .app-header {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 12px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
        }
        
        .header-logo img {
            height: 32px;
            width: 32px;
        }
        
        .header-logo span {
            font-size: 20px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .header-center {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .header-search {
            flex: 1;
            padding: 8px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .user-profile {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            position: relative;
        }
        
        .user-profile:hover {
            background-color: #f3f4f6;
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #e5e7eb;
        }
        
        .user-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-width: 200px;
            z-index: 1000;
        }
        
        .user-menu.active {
            display: block;
        }
        
        .user-menu button {
            width: 100%;
            text-align: left;
            padding: 12px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
        }
        
        .user-menu button:hover {
            background-color: #f3f4f6;
        }
        
        .btn-primary {
            padding: 8px 16px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }
        
        .btn-primary:hover {
            background: #1d4ed8;
        }
        
        .dropdown {
            position: relative;
        }
        
        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-width: 150px;
            z-index: 1000;
        }
        
        .dropdown-menu.active {
            display: block;
        }
        
        .dropdown-menu button {
            width: 100%;
            text-align: left;
            padding: 12px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
        }
        
        .dropdown-menu button:hover {
            background-color: #f3f4f6;
        }
        
        /* Boards sections */
        .boards-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 32px 24px;
        }
        
        .boards-section {
            margin-bottom: 48px;
        }
        
        .boards-section h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #1f2937;
        }
        
        .boards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 16px;
        }
        
        .board-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .board-card:hover {
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .board-card h3 {
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 8px 0;
            color: #1f2937;
        }
        
        .board-card p {
            font-size: 14px;
            color: #6b7280;
            margin: 0;
        }
        
        .board-card-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
        }
        
        .board-card-actions button {
            flex: 1;
            padding: 6px 12px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 13px;
        }
        
        .board-card-actions button:hover {
            background: #f3f4f6;
        }
        
        .board-card-actions .delete-btn {
            color: #dc2626;
            border-color: #dc2626;
        }
        
        .board-card-actions .delete-btn:hover {
            background: #fef2f2;
        }
        
        .empty-state {
            text-align: center;
            padding: 48px 24px;
            color: #6b7280;
        }
        
        .whiteboard-header {
            display: none;
        }
        
        #whiteboard-view.active .whiteboard-header {
            display: flex;
        }
        
        #whiteboard-view.active #toolbar-wrapper {
            top: 60px;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .header-center {
                display: none;
            }
            
            .header-logo span {
                display: none;
            }
            
            .boards-grid {
                grid-template-columns: 1fr;
            }
        }
        /* The canvas itself */
        #whiteboard {
            display: block;
            /* Changed from 'none' to 'crosshair' so cursor is visible if JS fails */
            cursor: crosshair; 
            touch-action: none; /* Disables browser gestures like double-tap-to-zoom */
        }
        
        #whiteboard.panning {
            cursor: grab;
        }

        #whiteboard.panning:active {
            cursor: grabbing;
        }

        #custom-cursor-circle {
            position: fixed;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            background-color: transparent; 
            border: 1px solid rgba(0,0,0,0.5); 
            border-radius: 50%;
            pointer-events: none; 
            transform: translate(-50%, -50%);
            z-index: 9999;
            transition: width 0.1s ease, height 0.1s ease;
            display: none; 
            box-shadow: 0 0 0 1px rgba(255,255,255,0.5); /* Inner contrast ring */
        }
        
        #custom-cursor-eraser {
            position: fixed;
            top: 0;
            left: 0;
            width: 24px;
            height: 24px;
            pointer-events: none;
            transform: translate(-4px, -22px); 
            z-index: 9999;
            display: none; 
            filter: drop-shadow(0px 1px 2px rgba(0,0,0,0.3));
        }
        
        #custom-cursor-eraser svg {
            width: 100%;
            height: 100%;
            fill: white; 
            stroke: #333;
            stroke-width: 1.5;
        }

        #whiteboard.panning + #custom-cursor-circle,
        #whiteboard.panning + #custom-cursor-eraser {
            display: none;
        }

        #save-indicator {
            transition: opacity 0.5s ease-out;
            background-color: #16a34a; /* green-600 */
        }
        
        /* Custom color input */
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 100%; 
            height: 40px; 
            padding: 0;
            border: none;
            border-radius: 0.375rem; 
            cursor: pointer;
            background-color: transparent;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 0.375rem;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 2px solid #e2e8f0; 
            border-radius: 0.375rem;
        }
        input[type="color"]::-moz-color-swatch {
            border: 2px solid #e2e8f0;
            border-radius: 0.375rem;
        }

        .tool-btn.active {
            background-color: #dbeafe; /* blue-100 */
            color: #2563eb; /* blue-600 */
            box-shadow: 0 0 0 2px #bfdbfe; /* blue-200 */
        }

        .tool-btn {
            padding: 0.75rem; /* p-3 */
            border-radius: 0.5rem; /* rounded-md */
        }
        .tool-btn svg {
            width: 1.75rem; /* w-7 */
            height: 1.75rem; /* h-7 */
            pointer-events: none;
        }
        
        .tool-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            background-color: transparent;
            color: currentColor;
            box-shadow: none;
        }

        /* NEW: Popover styles */
        .popover {
            display: none; 
            position: fixed; 
            background-color: white;
            border-radius: 0.5rem; 
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            padding: 1rem; 
            z-index: 20;
            width: 280px; 
            overflow-y: auto;
            max-height: 70vh; 
        }
        
        .popover.active {
            display: block;
        }
        
        /* Custom Scrollbar for Popovers */
        .popover::-webkit-scrollbar {
            width: 8px;
        }
        .popover::-webkit-scrollbar-track {
            background: #f1f5f9; 
            border-radius: 10px;
        }
        .popover::-webkit-scrollbar-thumb {
            background: #cbd5e1; 
            border-radius: 10px;
        }
        .popover::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; 
        }

        /* Styles for thickness input */
        .thickness-control {
            display: flex;
            align-items: center;
            gap: 0.5rem; 
        }
        .thickness-control input[type="number"] {
            width: 4rem; 
            text-align: center;
            border: 1px solid #d1d5db; 
            border-radius: 0.375rem; 
            padding: 0.25rem 0.5rem; 
            -moz-appearance: textfield; 
        }
        .thickness-control input[type="number"]::-webkit-outer-spin-button,
        .thickness-control input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none; 
            margin: 0;
        }
        .thickness-control button {
            width: 2rem; 
            height: 2rem; 
            font-size: 1.25rem; 
            font-weight: 600; 
            border: 1px solid #d1d5db; 
            border-radius: 0.375rem; 
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f9fafb; 
            color: #374151; 
        }
        .thickness-control button:hover {
            background-color: #f3f4f6; 
        }

        /* Styles for compact mode */
        .compact-mode .tool-btn {
            padding: 0.25rem; 
        }
        .compact-mode .tool-btn svg {
            width: 1.25rem; 
            height: 1.25rem; 
        }
        .compact-mode #toolbar {
            padding: 0.5rem; 
            gap: 0.25rem; 
        }
        /* Transition for smooth shrink/expand */
        #toolbar, .tool-btn, .tool-btn svg {
            transition: all 0.15s ease-in-out;
        }
        
        /* Custom scrollbar for toolbar */
        #toolbar::-webkit-scrollbar {
            height: 4px; 
        }
        #toolbar::-webkit-scrollbar-track {
            background: transparent;
        }
        #toolbar::-webkit-scrollbar-thumb {
            background: #cbd5e1; 
            border-radius: 10px;
        }
        #toolbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; 
        }
        
        /* Preview box styles */
        .preview-box {
            width: 100%;
            height: 60px;
            background-color: #f3f4f6; 
            border: 1px solid #e5e7eb; 
            border-radius: 0.375rem; 
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        #pen-preview {
            width: 100%;
            height: 5px; 
            background-color: #000;
            border-radius: 99px;
            transition: height 0.1s ease;
        }
        #eraser-preview {
            width: 20px; 
            height: 20px; 
            background-color: #9ca3af; 
            border-radius: 50%;
            transition: all 0.1s ease;
        }
        
        /* Text tool styles - Microsoft Office-like text box */
        .text-input-overlay {
            position: fixed;
            display: none;
            z-index: 10000;
            background: white;
            border: 2px solid #2563eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            min-width: 300px;
            max-width: 600px;
        }
        
        .text-input-overlay.active {
            display: block;
        }
        
        .text-input-toolbar {
            display: flex;
            gap: 4px;
            padding: 8px;
            background: #f3f4f6;
            border-bottom: 1px solid #e5e7eb;
            border-radius: 6px 6px 0 0;
            align-items: center;
        }
        
        .text-input-toolbar button,
        .text-input-toolbar select {
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .text-input-toolbar button:hover {
            background: #e5e7eb;
        }
        
        .text-input-toolbar button.active {
            background: #dbeafe;
            border-color: #2563eb;
            color: #2563eb;
        }
        
        .text-input-overlay textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            font-size: 16px;
            border: none;
            border-radius: 0 0 6px 6px;
            outline: none;
            resize: vertical;
            font-family: inherit;
        }
        
        .text-input-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 8px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            border-radius: 0 0 6px 6px;
        }
        
        .text-input-footer button {
            padding: 6px 16px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .text-input-footer button.primary {
            background: #2563eb;
            color: white;
            border-color: #2563eb;
        }
        
        .text-input-footer button.primary:hover {
            background: #1d4ed8;
        }
        
        .text-input-footer button.secondary {
            background: white;
        }
        
        .text-input-footer button.secondary:hover {
            background: #f3f4f6;
        }
    </style>
</head>
<body class="font-sans antialiased">

    <!-- Debug Error Box -->
    <div id="global-error-box"></div>

    <!-- Loading Screen (Pure HTML/CSS) -->
    <div id="app-loading">
        <div class="loading-spinner"></div>
        <h2 style="font-size: 1.25rem; font-weight: 600;">Loading Whiteboard...</h2>
        <p style="font-size: 0.875rem; margin-top: 0.5rem;">Init...</p>
    </div>
    
    <!-- Homepage View -->
    <div id="homepage-view" class="view active">
        <!-- Header -->
        <div class="app-header">
            <div class="header-logo" onclick="window.goToHomepage()">
                <img src="WebBoard.png" alt="Webboard Logo">
                <span>Webboard</span>
            </div>
            
            <div class="header-center">
                <input type="text" class="header-search" placeholder="Search boards..." id="board-search">
                <div class="dropdown">
                    <button class="btn-primary" id="new-board-btn">+ New Board</button>
                    <div class="dropdown-menu" id="new-board-menu">
                        <button onclick="window.createNewBoard('local')">Local Board</button>
                        <button onclick="window.createNewBoard('cloud')" id="cloud-board-option">Cloud Board</button>
                    </div>
                </div>
            </div>
            
            <div class="header-right">
                <div id="buttonDiv" style="display: flex; align-items: center;"></div>
                <div id="user-profile-area" style="display: none;">
                    <div class="user-profile" id="user-profile-btn">
                        <img id="user-avatar" class="user-avatar" src="" alt="User">
                        <span id="user-name"></span>
                        <div class="user-menu" id="user-menu">
                            <button onclick="window.signOut()">Sign Out</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Boards Container -->
        <div class="boards-container">
            <!-- Local Boards Section -->
            <div class="boards-section">
                <h2>On your Computer</h2>
                <div id="local-boards-grid" class="boards-grid">
                    <!-- Local boards will be rendered here -->
                </div>
            </div>
            
            <!-- Cloud Boards Section -->
            <div class="boards-section" id="cloud-boards-section" style="display: none;">
                <h2><span id="cloud-boards-title">My Boards</span></h2>
                <div id="cloud-boards-grid" class="boards-grid">
                    <!-- Cloud boards will be rendered here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Whiteboard View -->
    <div id="whiteboard-view" class="view">
        <!-- Persistent Header for Whiteboard -->
        <div class="app-header whiteboard-header">
            <div class="header-logo" onclick="window.goToHomepage()">
                <img src="WebBoard.png" alt="Webboard Logo">
                <span>Webboard</span>
            </div>
            
            <div class="header-right">
                <button id="save-drawing-btn-header" onclick="window.promptSaveDrawing()" class="btn-primary" style="display: none;">
                    Save to Cloud
                </button>
                <div id="user-profile-area-whiteboard" style="display: none;">
                    <div class="user-profile">
                        <img id="user-avatar-whiteboard" class="user-avatar" src="" alt="User">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Toolbar wrapper -->
        <div id="toolbar-wrapper" class="fixed top-4 left-0 right-0 z-10 flex justify-center compact-mode pointer-events-none">
            <div id="toolbar" class="relative bg-white rounded-lg shadow-xl p-3 flex items-center justify-start flex-nowrap gap-x-2 md:gap-x-4 select-none overflow-x-auto max-w-[95vw] pointer-events-auto">
                
                <div id="pen-tool-wrapper" class="flex flex-col items-center">
                    <button id="pen-btn" class="tool-btn rounded-md active" title="Pen (1)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none" style="stroke: #000000;">
                            <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>
                        </svg>
                    </button>
                </div>
                <div id="eraser-tool-wrapper" class="flex flex-col items-center">
                    <button id="eraser-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Object Eraser (2)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                            <path d="M7 21H3a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h18a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4.27"/><path d="M17 11.73C17 10.67 16.33 10 15 10s-2 .67-2 1.73S13.67 14 15 14s2-.67 2-1.73Z"/><path d="M21.19 11.73c0-4.24-7.2-4.24-7.2 0C14 10.67 14.67 10 16 10s2 .67 2 1.73Z" transform="rotate(-30 16 11.73)"/>
                        </svg>
                    </button>
                </div>
                <div class="flex flex-col items-center">
                    <button id="text-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Text (3)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                            <polyline points="4 7 4 4 20 4 20 7"></polyline>
                            <line x1="9" y1="20" x2="15" y2="20"></line>
                            <line x1="12" y1="4" x2="12" y2="20"></line>
                        </svg>
                    </button>
                </div>
                <div class="flex flex-col items-center">
                    <button id="undo-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Undo (Ctrl+Z)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                            <path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                        </svg>
                    </button>
                </div>
                <div class="flex flex-col items-center">
                    <button id="redo-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Redo (Ctrl+Y)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                            <path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 0 9 9 9 9 0 0 0 6-2.3L21 13"/>
                        </svg>
                    </button>
                </div>
                <div class="flex flex-col items-center">
                    <button id="line-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Line">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                </div>
                <div class="flex flex-col items-center">
                    <button id="rect-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Rectangle">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        </svg>
                    </button>
                </div>
                <div class="flex flex-col items-center">
                    <button id="circle-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Circle">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                            <circle cx="12" cy="12" r="10"></circle>
                        </svg>
                    </button>
                </div>
                <div class="flex flex-col items-center">
                    <button id="triangle-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Triangle">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                        </svg>
                    </button>
                </div>
                <div id="canvas-tool-wrapper" class="flex flex-col items-center">
                    <button id="canvas-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Canvas Settings">
                        <svg id="canvas-icon-preview" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                            <rect id="canvas-icon-bg" x="3" y="3" width="18" height="18" rx="2" ry="2" fill="#ffffff" stroke="#d1d5db" stroke-width="1.5"/><g id="canvas-icon-ruled" style="display: none;" stroke="#d1d5db" stroke-width="1"><path d="M 6 8 L 18 8"></path><path d="M 6 12 L 18 12"></path><path d="M 6 16 L 18 16"></path></g><g id="canvas-icon-grid" style="display: none;" stroke="#d1d5db" stroke-width="1"><path d="M 8 6 L 8 18"></path><path d="M 12 6 L 12 18"></path><path d="M 16 6 L 16 18"></path><path d="M 6 8 L 18 8"></path><path d="M 6 12 L 18 12"></path><path d="M 6 16 L 18 16"></path></g>
                        </svg>
                    </button>
                </div>
                <div class="flex flex-col items-center">
                    <button id="clear-btn" class="tool-btn rounded-md hover:bg-red-100 text-red-600" title="Clear Canvas (Delete)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7">
                            <path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/>
                        </svg>
                    </button>
                </div>
                
            </div>
        </div>

        <!-- Save Indicator -->
        <div id="save-indicator" class="fixed bottom-4 right-4 text-white text-sm px-3 py-1 rounded-full shadow-lg opacity-0 select-none pointer-events-none z-50">
            Saved!
        </div>

        <!-- Canvas -->
        <canvas id="whiteboard"></canvas>
        <div id="custom-cursor-circle"></div>
        <div id="custom-cursor-eraser">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                <path d="M16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4 4 0 0 1-5.66 0L2.81 17c-.78-.79-.78-2.05 0-2.84l10.6-10.6c.79-.78 2.05-.78 2.83 0M4.22 15.58l3.54 3.53c.78.79 2.04.79 2.83 0l3.53-3.53l-4.95-4.95l-4.95 4.95z"/>
            </svg>
        </div>
        
        <!-- Text input overlay with Microsoft Office-like interface -->
        <div class="text-input-overlay" id="text-input-overlay">
            <div class="text-input-toolbar">
                <select id="text-font-family" title="Font Family">
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="'Times New Roman', serif">Times New Roman</option>
                    <option value="'Courier New', monospace">Courier New</option>
                    <option value="Georgia, serif">Georgia</option>
                    <option value="Verdana, sans-serif">Verdana</option>
                    <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                </select>
                <select id="text-font-size" title="Font Size">
                    <option value="12">12</option>
                    <option value="14">14</option>
                    <option value="16" selected>16</option>
                    <option value="18">18</option>
                    <option value="20">20</option>
                    <option value="24">24</option>
                    <option value="28">28</option>
                    <option value="32">32</option>
                    <option value="36">36</option>
                    <option value="48">48</option>
                    <option value="72">72</option>
                </select>
                <button id="text-bold" title="Bold (Ctrl+B)" style="font-weight: bold;">B</button>
                <button id="text-italic" title="Italic (Ctrl+I)" style="font-style: italic;">I</button>
                <button id="text-underline" title="Underline (Ctrl+U)" style="text-decoration: underline;">U</button>
            </div>
            <textarea id="text-input" placeholder="Enter text here..."></textarea>
            <div class="text-input-footer">
                <button class="secondary" id="text-cancel">Cancel</button>
                <button class="primary" id="text-submit">Add Text</button>
            </div>
        </div>
    </div>

    <!-- Popovers -->
    <div id="pen-popover" class="popover">
        <div class="flex flex-col gap-4">
            <div class="flex flex-col items-center">
                <label class="text-sm font-medium text-gray-700 mb-2">Preview</label>
                <div class="preview-box">
                    <div id="pen-preview"></div>
                </div>
            </div>
            <div class="flex flex-col items-center">
                <label class="text-sm font-medium text-gray-700 mb-2">Brush Color</label>
                <input type="color" id="color-picker" value="#000000" title="Brush Color">
            </div>
            <div class="flex flex-col items-center">
                <label class="text-sm font-medium text-gray-700 mb-2">Thickness</label>
                <div class="thickness-control" data-type="pen">
                    <button data-action="decrease" title="Decrease size">-</button>
                    <input type="number" class="th-input" min="1" max="500" value="5">
                    <button data-action="increase" title="Increase size">+</button>
                </div>
                <span id="pen-size-label" class="text-xs text-gray-500 mt-1">5px</span>
            </div>
        </div>
    </div>
    <div id="eraser-popover" class="popover">
        <div class="flex flex-col gap-4">
            <div class="flex flex-col items-center">
                <label class="text-sm font-medium text-gray-700 mb-2">Preview</label>
                <div class="preview-box">
                    <div id="eraser-preview"></div>
                </div>
            </div>
            <div class="flex flex-col items-center">
                <label class="text-sm font-medium text-gray-700 mb-2">Eraser Mode</label>
                <div class="flex w-full rounded-md shadow-sm">
                    <button id="object-eraser-btn" class="w-1/2 rounded-l-md px-4 py-2 text-sm font-medium border border-gray-300 bg-blue-100 text-blue-700">Object</button>
                    <button id="pixel-eraser-btn" class="w-1/2 rounded-r-md px-4 py-2 text-sm font-medium border border-gray-300 bg-white text-gray-700 hover:bg-gray-50">Pixel</button>
                </div>
            </div>
            <div class="flex flex-col items-center">
                <label class="text-sm font-medium text-gray-700 mb-2">Thickness</label>
                <div class="thickness-control" data-type="eraser">
                    <button data-action="decrease" title="Decrease size">-</button>
                    <input type="number" class="th-input" min="1" max="500" value="20">
                    <button data-action="increase" title="Increase size">+</button>
                </div>
                <span id="eraser-size-label" class="text-xs text-gray-500 mt-1">20px</span>
            </div>
        </div>
    </div>
    <div id="canvas-popover" class="popover">
        <div class="flex flex-col gap-4">
            <div class="flex flex-col items-center">
                <label class="text-sm font-medium text-gray-700 mb-2">Background Color</label>
                <input type="color" id="bg-color-picker" value="#FFFFFF" title="Background Color (for new canvas)">
            </div>
            <div class="flex flex-col items-center">
                <label class="text-sm font-medium text-gray-700 mb-2">Background Pattern</label>
                <select id="bg-pattern" class="w-full text-sm border border-gray-300 rounded-md p-2" title="Background Pattern (for new canvas)">
                    <option value="plain">Plain</option>
                    <option value="ruled">Ruled</option>
                    <option value="grid">Grid</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl w-11/12 max-w-sm">
            <h3 class="text-lg font-medium mb-4">Clear Canvas?</h3>
            <p class="text-sm text-gray-600 mb-6">This will permanently erase all drawings. This action cannot be undone.</p>
            <div class="flex justify-end space-x-3">
                <button id="cancel-clear" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Cancel</button>
                <button id="confirm-clear" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Drawing Area & Cursors -->
    <canvas id="whiteboard"></canvas>
    <div id="custom-cursor-circle"></div>
    <div id="custom-cursor-eraser">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="m19 21-7-7-4 4L2 12l9-9 4 4 7 7Z"/><path d="m18 11 4-4"/>
        </svg>
    </div>

    <!-- Google Sign-In Library -->
    <!-- LOADED LAST to avoid race conditions -->
    <script src="https://accounts.google.com/gsi/client" async defer onload="if(window.initGoogleAuth) window.initGoogleAuth()"></script>

    <script>
    
    // ===== CONFIGURATION =====
    // ⚠️ IMPORTANT: Google Sign-In Configuration
    // The default Client ID below is a demo ID and will show "Access blocked: Authorization error"
    // To fix this, you MUST create your own Google OAuth Client ID:
    // 1. Go to https://console.cloud.google.com/apis/credentials
    // 2. Create a new OAuth 2.0 Client ID (Web application type)
    // 3. Add your domain to "Authorized JavaScript origins"
    // 4. Replace the GOOGLE_CLIENT_ID below with your Client ID
    // 
    // For detailed instructions, see: ENV_SETUP_GUIDE.md
    const GOOGLE_CLIENT_ID = '263202480558-jm6e5brpr0l00nlrcrer2vjvvtpcfr1r.apps.googleusercontent.com';
    
    // ===== Consolidated Application Logic =====
    
    // Safety Timeout: If app doesn't load in 5 seconds, hide loader anyway so user can see what's wrong (or right)
    setTimeout(function() {
        var loader = document.getElementById('app-loading');
        if (loader && loader.style.display !== 'none') {
            console.warn("Loading timeout reached. Forcing loader hide.");
            loader.style.opacity = '0';
            setTimeout(function() { loader.style.display = 'none'; }, 300);
        }
    }, 5000);

    // --- Authentication ---
    
    window.initGoogleAuth = function() {
        console.log("initGoogleAuth called");
        if (typeof google === 'undefined' || !google.accounts) {
            console.error("Google library not loaded. Check network connection.");
            console.log("typeof google:", typeof google);
            
            // Show error message to user
            const btnDiv = document.getElementById('buttonDiv');
            if (btnDiv) {
                btnDiv.innerHTML = '<div style="padding: 10px; background: #fee; border: 1px solid #fcc; border-radius: 4px; color: #c00; font-size: 12px; max-width: 300px;">⚠️ Google Sign-In unavailable. Check network connection.</div>';
            }
            return;
        }
        try {
            console.log("Initializing Google Sign-In...");
            google.accounts.id.initialize({
                client_id: GOOGLE_CLIENT_ID,
                callback: window.handleCredentialResponse,
                auto_select: false
            });
            
            const btnDiv = document.getElementById('buttonDiv');
            console.log("buttonDiv element:", btnDiv);
            console.log("buttonDiv display style:", btnDiv ? btnDiv.style.display : 'element not found');
            
            if (btnDiv) {
                // Clear any previous error messages
                btnDiv.innerHTML = '';
                
                google.accounts.id.renderButton(
                    btnDiv,
                    { theme: 'outline', size: 'large', locale: 'en' }
                );
                console.log("Google Sign-In button rendered successfully");
                
                // Show configuration notice if using demo Client ID
                if (GOOGLE_CLIENT_ID === '263202480558-jm6e5brpr0l00nlrcrer2vjvvtpcfr1r.apps.googleusercontent.com') {
                    const notice = document.createElement('div');
                    notice.style.cssText = 'margin-top: 8px; padding: 8px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; color: #856404; font-size: 11px; max-width: 300px;';
                    notice.innerHTML = '⚠️ Using demo Client ID. Sign-in may fail with "Access blocked" error. See <a href="ENV_SETUP_GUIDE.md" target="_blank" style="color: #004085; text-decoration: underline;">setup guide</a> to configure your own.';
                    btnDiv.appendChild(notice);
                }
            } else {
                console.error("buttonDiv element not found!");
            }
        } catch (e) {
            console.error("Auth Init Error:", e);
            
            // Show error to user
            const btnDiv = document.getElementById('buttonDiv');
            if (btnDiv) {
                btnDiv.innerHTML = '<div style="padding: 10px; background: #fee; border: 1px solid #fcc; border-radius: 4px; color: #c00; font-size: 12px; max-width: 300px;">⚠️ Google Sign-In error: ' + e.message + '</div>';
            }
        }
    };

    window.handleCredentialResponse = async function(response) {
      try {
        console.log("Authenticating with backend...");
        
        // Send credential to backend
        const authResponse = await fetch('/api/google', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ credential: response.credential })
        });
        
        if (!authResponse.ok) {
          let errorMessage = 'Authentication failed';
          // Clone response so we can read it multiple times if needed
          const responseClone = authResponse.clone();
          try {
            const errorData = await authResponse.json();
            errorMessage = errorData.error || errorMessage;
          } catch (e) {
            // Response is not JSON, likely HTML error page
            try {
              const errorText = await responseClone.text();
              console.error('Non-JSON error response:', errorText);
            } catch (textError) {
              console.error('Could not read error response');
            }
            errorMessage = `Server error (${authResponse.status})`;
          }
          throw new Error(errorMessage);
        }
        
        const authData = await authResponse.json();
        
        // Store auth data
        localStorage.setItem('authToken', authData.token);
        localStorage.setItem('userId', authData.user.userId);
        localStorage.setItem('userEmail', authData.user.email);
        localStorage.setItem('userName', authData.user.name);
        localStorage.setItem('userPicture', authData.user.picture || '');
        
        showNotification('Signed in successfully!', 'success');
        updateAuthUI();
      } catch (error) {
        console.error('Sign-in error:', error);
        showNotification('Sign-in failed: ' + error.message, 'error');
      }
    };
    
    function showNotification(message, type) {
      const notif = document.createElement('div');
      notif.className = `notification notification-${type}`;
      notif.textContent = message;
      notif.style.cssText = `
        position: fixed; top: 80px; right: 20px;
        background: ${type === 'success' ? '#4CAF50' : '#f44336'};
        color: white; padding: 12px 24px; border-radius: 4px;
        z-index: 10000; font-family: Arial, sans-serif; font-weight: 500;
      `;
      document.body.appendChild(notif);
      setTimeout(() => notif.remove(), 3000);
    }
    
    function updateAuthUI() {
      const token = localStorage.getItem('authToken');
      const userEmail = localStorage.getItem('userEmail');
      const userName = localStorage.getItem('userName');
      const userPicture = localStorage.getItem('userPicture');
      const btnDiv = document.getElementById('buttonDiv');
      const userProfileArea = document.getElementById('user-profile-area');
      const userProfileAreaWhiteboard = document.getElementById('user-profile-area-whiteboard');
      const saveBtn = document.getElementById('save-drawing-btn-header');
      const cloudBoardOption = document.getElementById('cloud-board-option');
      const cloudBoardsSection = document.getElementById('cloud-boards-section');
      
      console.log("updateAuthUI called - token:", token ? "exists" : "none", "email:", userEmail);
      
      if (token && userEmail) {
        console.log("User is signed in");
        if(btnDiv) btnDiv.style.display = 'none';
        if(userProfileArea) userProfileArea.style.display = 'block';
        if(userProfileAreaWhiteboard) userProfileAreaWhiteboard.style.display = 'block';
        if(saveBtn) saveBtn.style.display = 'block';
        if(cloudBoardOption) cloudBoardOption.style.display = 'block';
        if(cloudBoardsSection) cloudBoardsSection.style.display = 'block';
        
        // Update user profile on homepage
        const userNameEl = document.getElementById('user-name');
        const userAvatarEl = document.getElementById('user-avatar');
        if (userNameEl) userNameEl.textContent = userName || userEmail;
        if (userAvatarEl && userPicture) userAvatarEl.src = userPicture;
        else if (userAvatarEl) userAvatarEl.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23999"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/></svg>';
        
        // Update user profile on whiteboard
        const userAvatarWhiteboardEl = document.getElementById('user-avatar-whiteboard');
        if (userAvatarWhiteboardEl && userPicture) userAvatarWhiteboardEl.src = userPicture;
        else if (userAvatarWhiteboardEl) userAvatarWhiteboardEl.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23999"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/></svg>';
        
        // Update cloud boards title
        const cloudBoardsTitle = document.getElementById('cloud-boards-title');
        if (cloudBoardsTitle) cloudBoardsTitle.textContent = `${userName || userEmail}'s Boards`;
        
        // Load cloud boards
        if (window.loadCloudBoards) window.loadCloudBoards();
      } else {
        console.log("User is NOT signed in");
        if(btnDiv) btnDiv.style.display = 'flex';
        if(userProfileArea) userProfileArea.style.display = 'none';
        if(userProfileAreaWhiteboard) userProfileAreaWhiteboard.style.display = 'none';
        if(saveBtn) saveBtn.style.display = 'none';
        if(cloudBoardOption) cloudBoardOption.style.display = 'none';
        if(cloudBoardsSection) cloudBoardsSection.style.display = 'none';
      }
      
      // Refresh boards display
      if (window.renderLocalBoards) window.renderLocalBoards();
    }
    
    window.signOut = function() {
      console.log("Signing out...");
      localStorage.removeItem('authToken');
      localStorage.removeItem('userId');
      localStorage.removeItem('userEmail');
      localStorage.removeItem('userName');
      localStorage.removeItem('userPicture');
      updateAuthUI();
      showNotification('Signed out', 'success');
      window.goToHomepage();
      // Re-render button
      setTimeout(() => {
        console.log("Re-initializing Google Sign-In after sign out");
        window.initGoogleAuth();
      }, 100);
    }
    
    // --- View Management ---
    window.goToHomepage = function() {
      document.getElementById('homepage-view').classList.add('active');
      document.getElementById('whiteboard-view').classList.remove('active');
      // Save current whiteboard if there's data
      if (window.getCurrentBoardId && window.getCurrentBoardId()) {
        window.saveCurrentLocalBoard();
      }
      window.renderLocalBoards();
      if (localStorage.getItem('authToken')) {
        window.loadCloudBoards();
      }
    }
    
    window.goToWhiteboard = function(boardId) {
      document.getElementById('homepage-view').classList.remove('active');
      document.getElementById('whiteboard-view').classList.add('active');
      if (boardId) {
        window.loadBoard(boardId);
      }
    }
    
    // --- Local Board Management ---
    let currentBoardId = null;
    
    window.getCurrentBoardId = function() {
      return currentBoardId;
    }
    
    window.setCurrentBoardId = function(id) {
      currentBoardId = id;
    }
    
    window.createNewBoard = function(type) {
      if (type === 'cloud' && !localStorage.getItem('authToken')) {
        showNotification('Please sign in to create cloud boards', 'error');
        return;
      }
      
      const boardId = 'board_' + Date.now();
      const boardTitle = prompt('Enter board title:', 'Untitled Board');
      if (!boardTitle) return;
      
      if (type === 'local') {
        const board = {
          id: boardId,
          title: boardTitle,
          type: 'local',
          lastModified: Date.now(),
          data: { strokes: [], backgroundColor: '#FFFFFF', backgroundPattern: 'plain', viewOffset: { x: 0, y: 0 }, viewZoom: 1 }
        };
        
        const boards = JSON.parse(localStorage.getItem('localBoards') || '[]');
        boards.push(board);
        localStorage.setItem('localBoards', JSON.stringify(boards));
        
        currentBoardId = boardId;
        window.goToWhiteboard(boardId);
      } else {
        // For cloud boards, create empty and switch to whiteboard
        currentBoardId = null; // Will be set after first save
        window.goToWhiteboard();
      }
    }
    
    window.loadBoard = function(boardId) {
      const boards = JSON.parse(localStorage.getItem('localBoards') || '[]');
      const board = boards.find(b => b.id === boardId);
      
      if (board) {
        currentBoardId = boardId;
        if (window.loadDrawingData) {
          window.loadDrawingData(board.data);
        }
      }
    }
    
    window.saveCurrentLocalBoard = function() {
      if (!currentBoardId) return;
      
      const boards = JSON.parse(localStorage.getItem('localBoards') || '[]');
      const boardIndex = boards.findIndex(b => b.id === currentBoardId);
      
      if (boardIndex !== -1 && window.getDrawingData) {
        boards[boardIndex].data = window.getDrawingData();
        boards[boardIndex].lastModified = Date.now();
        localStorage.setItem('localBoards', JSON.stringify(boards));
      }
    }
    
    window.deleteLocalBoard = function(boardId) {
      if (!confirm('Delete this board?')) return;
      
      const boards = JSON.parse(localStorage.getItem('localBoards') || '[]');
      const filtered = boards.filter(b => b.id !== boardId);
      localStorage.setItem('localBoards', JSON.stringify(filtered));
      window.renderLocalBoards();
      showNotification('Board deleted', 'success');
    }
    
    window.renderLocalBoards = function() {
      const grid = document.getElementById('local-boards-grid');
      if (!grid) return;
      
      const boards = JSON.parse(localStorage.getItem('localBoards') || '[]');
      
      if (boards.length === 0) {
        grid.innerHTML = '<div class="empty-state">No local boards yet. Create one to get started!</div>';
        return;
      }
      
      grid.innerHTML = boards.map(board => `
        <div class="board-card" onclick="window.goToWhiteboard('${board.id}')">
          <h3>${board.title}</h3>
          <p>${new Date(board.lastModified).toLocaleString()}</p>
          <div class="board-card-actions" onclick="event.stopPropagation()">
            <button onclick="window.deleteLocalBoard('${board.id}')" class="delete-btn">Delete</button>
          </div>
        </div>
      `).join('');
    }
    
    window.loadCloudBoards = async function() {
      const grid = document.getElementById('cloud-boards-grid');
      if (!grid) return;
      
      try {
        const token = localStorage.getItem('authToken');
        if (!token) return;
        
        const response = await fetch('/api/list', {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!response.ok) throw new Error('Failed to load cloud boards');
        
        const drawings = await response.json();
        
        if (drawings.length === 0) {
          grid.innerHTML = '<div class="empty-state">No cloud boards yet.</div>';
          return;
        }
        
        grid.innerHTML = drawings.map(drawing => `
          <div class="board-card" onclick="window.loadCloudBoard('${drawing.id}')">
            <h3>${drawing.title}</h3>
            <p>${new Date(drawing.createdAt).toLocaleString()}</p>
            <div class="board-card-actions" onclick="event.stopPropagation()">
              <button onclick="window.deleteCloudBoard('${drawing.id}')" class="delete-btn">Delete</button>
            </div>
          </div>
        `).join('');
      } catch (error) {
        console.error('Load cloud boards error:', error);
        grid.innerHTML = '<div class="empty-state">Failed to load cloud boards</div>';
      }
    }
    
    window.loadCloudBoard = async function(drawingId) {
      try {
        const token = localStorage.getItem('authToken');
        const response = await fetch(`/api/load/${drawingId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!response.ok) throw new Error('Failed to load drawing');
        
        const drawing = await response.json();
        currentBoardId = null; // Cloud board, not local
        window.goToWhiteboard();
        if (window.loadDrawingData) {
          window.loadDrawingData(drawing.drawingData);
        }
      } catch (error) {
        console.error('Load cloud board error:', error);
        showNotification('Failed to load: ' + error.message, 'error');
      }
    }
    
    window.deleteCloudBoard = async function(drawingId) {
      if (!confirm('Delete this cloud board?')) return;
      
      try {
        const token = localStorage.getItem('authToken');
        const response = await fetch(`/api/delete/${drawingId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!response.ok) throw new Error('Failed to delete');
        
        window.loadCloudBoards();
        showNotification('Board deleted', 'success');
      } catch (error) {
        console.error('Delete error:', error);
        showNotification('Failed to delete: ' + error.message, 'error');
      }
    }
    
    window.promptSaveDrawing = async function() {
      const title = prompt('Enter a title for your drawing:', `Drawing-${new Date().toLocaleDateString()}`);
      if (!title) return;
      
      try {
        const token = localStorage.getItem('authToken');
        if (!token) {
          showNotification('Please sign in first', 'error');
          return;
        }
        
        // Get the current drawing data
        const drawingData = window.getDrawingData ? window.getDrawingData() : { strokes: [] };
        
        // Send to backend
        const response = await fetch('/api/save', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            title: title,
            drawingData: drawingData
          })
        });
        
        if (!response.ok) {
          let errorMessage = 'Failed to save';
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorMessage;
          } catch (e) {
            errorMessage = `Server error (${response.status})`;
          }
          throw new Error(errorMessage);
        }
        
        const result = await response.json();
        showNotification(`Drawing "${title}" saved successfully!`, 'success');
      } catch (error) {
        console.error('Save error:', error);
        showNotification('Failed to save: ' + error.message, 'error');
      }
    }
    
    function initAuthStatus() {
      updateAuthUI();
      // Also try to initialize Google Auth if library is already loaded
      if (typeof google !== 'undefined' && google.accounts) {
        console.log("Google library already loaded, initializing...");
        initGoogleAuth();
      } else {
        console.log("Waiting for Google library to load...");
      }
    }

    // --- Main Application ---

    document.addEventListener('DOMContentLoaded', () => {
        try {
            // Remove loading screen after 500ms (debounce)
            setTimeout(() => {
                const loader = document.getElementById('app-loading');
                if(loader) {
                    loader.style.opacity = '0';
                    setTimeout(() => { loader.style.display = 'none'; }, 300);
                }
            }, 500);

            initAuthStatus();
            
            // --- Homepage UI Initialization ---
            const newBoardBtn = document.getElementById('new-board-btn');
            const newBoardMenu = document.getElementById('new-board-menu');
            const userProfileBtn = document.getElementById('user-profile-btn');
            const userMenu = document.getElementById('user-menu');
            const boardSearch = document.getElementById('board-search');
            
            // New board dropdown
            if (newBoardBtn && newBoardMenu) {
                newBoardBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    newBoardMenu.classList.toggle('active');
                });
                
                document.addEventListener('click', () => {
                    newBoardMenu.classList.remove('active');
                });
            }
            
            // User menu dropdown
            if (userProfileBtn && userMenu) {
                userProfileBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    userMenu.classList.toggle('active');
                });
                
                document.addEventListener('click', () => {
                    userMenu.classList.remove('active');
                });
            }
            
            // Board search
            if (boardSearch) {
                boardSearch.addEventListener('input', (e) => {
                    const query = e.target.value.toLowerCase();
                    document.querySelectorAll('.board-card').forEach(card => {
                        const title = card.querySelector('h3').textContent.toLowerCase();
                        card.style.display = title.includes(query) ? '' : 'none';
                    });
                });
            }
            
            // Initialize boards on homepage
            window.renderLocalBoards();
            if (localStorage.getItem('authToken')) {
                window.loadCloudBoards();
            }
            
            // --- All app variables ---
            const canvas = document.getElementById('whiteboard');
            if(!canvas) throw new Error("Canvas element not found");

            // Use 'true' alpha to be safe against compositing bugs in some browsers
            const ctx = canvas.getContext('2d', { alpha: true }); 

            const toolbar = document.getElementById('toolbar');
            const customCursorCircle = document.getElementById('custom-cursor-circle');
            const customCursorEraser = document.getElementById('custom-cursor-eraser');
            const toolbarWrapper = document.getElementById('toolbar-wrapper');

            // (Tool Buttons)
            const penBtn = document.getElementById('pen-btn');
            const eraserBtn = document.getElementById('eraser-btn');
            const textBtn = document.getElementById('text-btn');
            const lineBtn = document.getElementById('line-btn');
            const rectBtn = document.getElementById('rect-btn');
            const circleBtn = document.getElementById('circle-btn');
            const triangleBtn = document.getElementById('triangle-btn');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const clearBtn = document.getElementById('clear-btn');
            
            // Text tool elements
            const textInputOverlay = document.getElementById('text-input-overlay');
            const textInput = document.getElementById('text-input');
            const textFontFamily = document.getElementById('text-font-family');
            const textFontSize = document.getElementById('text-font-size');
            const textBoldBtn = document.getElementById('text-bold');
            const textItalicBtn = document.getElementById('text-italic');
            const textUnderlineBtn = document.getElementById('text-underline');
            const textSubmitBtn = document.getElementById('text-submit');
            const textCancelBtn = document.getElementById('text-cancel');
            
            // Text formatting state
            let textBold = false;
            let textItalic = false;
            let textUnderline = false;
            
            // (Canvas Tool)
            const canvasBtn = document.getElementById('canvas-btn');
            const canvasIconBg = document.getElementById('canvas-icon-bg');
            const canvasIconRuled = document.getElementById('canvas-icon-ruled');
            const canvasIconGrid = document.getElementById('canvas-icon-grid');
            
            // (Popovers)
            const penPopover = document.getElementById('pen-popover');
            const eraserPopover = document.getElementById('eraser-popover');
            const canvasPopover = document.getElementById('canvas-popover');
            
            // (Pen Popover)
            const colorPicker = document.getElementById('color-picker');
            const penThicknessControl = document.querySelector('.thickness-control[data-type="pen"]');
            const penThicknessInput = penThicknessControl.querySelector('input[type="number"]');
            const penSizeLabel = document.getElementById('pen-size-label');
            const penPreview = document.getElementById('pen-preview');
            
            // (Eraser Popover)
            const eraserThicknessControl = document.querySelector('.thickness-control[data-type="eraser"]');
            const eraserThicknessInput = eraserThicknessControl.querySelector('input[type="number"]');
            const eraserSizeLabel = document.getElementById('eraser-size-label');
            const objectEraserBtn = document.getElementById('object-eraser-btn');
            const pixelEraserBtn = document.getElementById('pixel-eraser-btn');
            const eraserPreview = document.getElementById('eraser-preview');
            
            // (Canvas Popover)
            const bgColorPicker = document.getElementById('bg-color-picker');
            const bgPatternSelector = document.getElementById('bg-pattern');
            
            const toolButtons = [
                { el: penBtn, tool: 'pen' },
                { el: eraserBtn, tool: 'eraser' },
                { el: textBtn, tool: 'text' },
                { el: lineBtn, tool: 'line' },
                { el: rectBtn, tool: 'rect' },
                { el: circleBtn, tool: 'circle' },
                { el: triangleBtn, tool: 'triangle' },
            ];
            
            const saveIndicator = document.getElementById('save-indicator');
            const confirmModal = document.getElementById('confirm-modal');
            const cancelClearBtn = document.getElementById('cancel-clear');
            const confirmClearBtn = document.getElementById('confirm-clear');

            // --- (LOCAL STATE) ---
            let strokes = []; 
            let currentPath = null; 
            let undoStack = [];
            let redoStack = [];
            
            let viewOffset = { x: 0, y: 0 };
            let viewZoom = 1; 
            let lastPanPos = { x: 0, y: 0 };
            
            let isDrawing = false;
            let isPanning = false;
            let didDeleteInStroke = false;
            let wheelSaveTimer = null; 

            let currentColor = '#000000';
            let currentBrushSize = 5;
            let currentTool = 'pen'; 
            let originalTool = 'pen'; 
            
            let currentEraserMode = 'object';
            let currentEraserSize = 20;
            
            let backgroundColor = '#FFFFFF';
            let backgroundPattern = 'plain';
            
            let isTwoFingerPanning = false;
            let lastTouchMidpoint = { x: 0, y: 0 };
            let lastTouchDistance = 0; // For pinch-zoom
            let isEraserGesture = false;
            
            // Hold-to-erase state
            let touchHoldTimer = null;
            const TOUCH_HOLD_DURATION = 500; 
            
            const MIN_ZOOM = 0.1;
            const MAX_ZOOM = 10.0;
            const ZOOM_STEP = 0.1;

            // CRITICAL FIX: High DPI (Retina) Support with Safety Check
            let dpr = window.devicePixelRatio || 1;
            if(dpr < 1) dpr = 1; // Sanity check

            // --- Coordinate Conversion ---
            function screenToWorld(screenX, screenY) {
                return { 
                    x: (screenX - viewOffset.x) / viewZoom, 
                    y: (screenY - viewOffset.y) / viewZoom 
                };
            }
            function worldToScreen(worldX, worldY) {
                return { 
                    x: worldX * viewZoom + viewOffset.x, 
                    y: worldY * viewZoom + viewOffset.y 
                };
            }

            // --- Canvas Setup ---
            function updateCanvasIconPreview() {
                canvasIconBg.setAttribute('fill', backgroundColor);
                canvasIconRuled.style.display = backgroundPattern === 'ruled' ? 'block' : 'none';
                canvasIconGrid.style.display = backgroundPattern === 'grid' ? 'block' : 'none';
                
                // Contrast check for icon lines
                const isDarkBg = (parseInt(backgroundColor.substr(1, 2), 16) * 0.299 + 
                                  parseInt(backgroundColor.substr(3, 2), 16) * 0.587 + 
                                  parseInt(backgroundColor.substr(5, 2), 16) * 0.114) < 186;
                const patternColor = isDarkBg ? '#FFFFFF' : '#d1d5db';
                canvasIconRuled.setAttribute('stroke', patternColor);
                canvasIconGrid.setAttribute('stroke', patternColor);
            }
            
            function drawBackground() {
                // Safety check for dimensions
                if (canvas.width === 0 || canvas.height === 0) return;

                // We use logical dimensions for drawing here because the context is already scaled by DPR
                const logicalW = canvas.width / dpr;
                const logicalH = canvas.height / dpr;

                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, logicalW, logicalH);
                
                if (backgroundPattern === 'plain') return;
                
                ctx.strokeStyle = '#E2E8F0';
                const isDarkBg = (parseInt(backgroundColor.substr(1, 2), 16) * 0.299 + 
                                  parseInt(backgroundColor.substr(3, 2), 16) * 0.587 + 
                                  parseInt(backgroundColor.substr(5, 2), 16) * 0.114) < 186;
                if(isDarkBg) ctx.strokeStyle = 'rgba(255,255,255,0.1)';

                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const worldLineSpacing = 30; 
                const screenLineSpacing = worldLineSpacing * viewZoom;
                
                if (screenLineSpacing > 5) {
                    const startX = viewOffset.x % screenLineSpacing;
                    const startY = viewOffset.y % screenLineSpacing;
                    
                    if (backgroundPattern === 'ruled') {
                        for (let y = startY; y < logicalH; y += screenLineSpacing) {
                            ctx.moveTo(0, y);
                            ctx.lineTo(logicalW, y);
                        }
                    } else if (backgroundPattern === 'grid') {
                        for (let y = startY; y < logicalH; y += screenLineSpacing) {
                            ctx.moveTo(0, y);
                            ctx.lineTo(logicalW, y);
                        }
                        for (let x = startX; x < logicalW; x += screenLineSpacing) {
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, logicalH);
                        }
                    }
                    ctx.stroke();
                }
            }

            function resizeCanvas() {
                dpr = window.devicePixelRatio || 1;
                // Safety check for dpr
                if(isNaN(dpr) || dpr <= 0) dpr = 1;
                
                // Set physical pixel size
                canvas.width = window.innerWidth * dpr;
                canvas.height = window.innerHeight * dpr;
                
                // Set CSS display size (logical pixels)
                canvas.style.width = `${window.innerWidth}px`;
                canvas.style.height = `${window.innerHeight}px`;
                
                render(); 
            }

            // --- Local Storage ---
            function showSaveIndicator() {
                saveIndicator.style.opacity = '1';
                setTimeout(() => {
                    saveIndicator.style.opacity = '0';
                }, 1500);
            }
            
            function saveViewTransform() {
                try {
                    localStorage.setItem('whiteboardView', JSON.stringify({ offset: viewOffset, zoom: viewZoom }));
                } catch (e) {
                    console.error("Error saving view transform", e);
                }
            }

            function saveStrokesAndSettings() {
                try {
                    localStorage.setItem('whiteboardStrokes', JSON.stringify(strokes));
                    localStorage.setItem('whiteboardBgColor', backgroundColor);
                    localStorage.setItem('whiteboardBgPattern', backgroundPattern);
                    showSaveIndicator();
                    // Also save to current local board if one is active
                    if (window.saveCurrentLocalBoard) {
                        window.saveCurrentLocalBoard();
                    }
                } catch (e) {
                    console.error("Error saving strokes", e);
                }
            }

            function loadFromStorage() {
                backgroundColor = localStorage.getItem('whiteboardBgColor') || '#FFFFFF';
                backgroundPattern = localStorage.getItem('whiteboardBgPattern') || 'plain';
                
                bgColorPicker.value = backgroundColor;
                bgPatternSelector.value = backgroundPattern;
                updateCanvasIconPreview();

                const viewDataStr = localStorage.getItem('whiteboardView');
                if (viewDataStr) {
                    try {
                        const viewData = JSON.parse(viewDataStr);
                        if (viewData) {
                            viewOffset = viewData.offset || { x: 0, y: 0 };
                            viewZoom = viewData.zoom || 1;
                        }
                    } catch (e) {
                        viewOffset = { x: 0, y: 0 };
                        viewZoom = 1;
                    }
                }
                
                const strokesData = localStorage.getItem('whiteboardStrokes');
                if (strokesData) {
                     try {
                        strokes = JSON.parse(strokesData);
                     } catch (e) {
                        strokes = [];
                     }
                }
                
                undoStack = [];
                redoStack = [];
                updateUndoRedoButtons();
                
                render();
            }
            
            // Simple autosave alias
            function autosave() {
                saveStrokesAndSettings();
            }

            // --- History (Undo/Redo) ---
            function addHistoryAction() {
                redoStack = []; 
                try {
                    undoStack.push(JSON.stringify(strokes));
                } catch (e) { console.warn("History full"); }
                if (undoStack.length > 50) { 
                    undoStack.shift();
                }
                updateUndoRedoButtons();
            }
            
            function updateUndoRedoButtons() {
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }
            
            function undo() {
                if (undoStack.length === 0) return;
                redoStack.push(JSON.stringify(strokes));
                try {
                    strokes = JSON.parse(undoStack.pop());
                    updateUndoRedoButtons();
                    render();
                    saveStrokesAndSettings();
                } catch(e) { console.error("Undo error", e); }
            }
            
            function redo() {
                if (redoStack.length === 0) return;
                undoStack.push(JSON.stringify(strokes));
                try {
                    strokes = JSON.parse(redoStack.pop());
                    updateUndoRedoButtons();
                    render();
                    saveStrokesAndSettings();
                } catch(e) { console.error("Redo error", e); }
            }

            // --- Shape Drawing Functions ---
            function drawStroke(stroke) {
                // Handle text rendering
                if (stroke.type === 'text') {
                    ctx.fillStyle = stroke.color;
                    
                    // Build font string with formatting
                    let fontStyle = '';
                    if (stroke.italic) fontStyle += 'italic ';
                    if (stroke.bold) fontStyle += 'bold ';
                    
                    const fontSize = stroke.fontSize || 16;
                    const fontFamily = stroke.fontFamily || 'Arial, sans-serif';
                    ctx.font = `${fontStyle}${fontSize}px ${fontFamily}`;
                    
                    // Handle multi-line text
                    const lines = stroke.text.split('\n');
                    const lineHeight = fontSize * 1.2;
                    
                    lines.forEach((line, index) => {
                        const y = stroke.y + (index * lineHeight);
                        ctx.fillText(line, stroke.x, y);
                        
                        // Draw underline if needed
                        if (stroke.underline) {
                            const textWidth = ctx.measureText(line).width;
                            ctx.beginPath();
                            ctx.strokeStyle = stroke.color;
                            ctx.lineWidth = Math.max(1, fontSize / 16);
                            ctx.moveTo(stroke.x, y + 2);
                            ctx.lineTo(stroke.x + textWidth, y + 2);
                            ctx.stroke();
                        }
                    });
                    return;
                }
                
                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = stroke.size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                switch (stroke.tool) {
                    case 'pen':
                        if (stroke.points.length < 2) {
                            // Draw a dot if it's a single point
                             if (stroke.points.length === 1) {
                                ctx.fillStyle = stroke.color;
                                ctx.arc(stroke.points[0].x, stroke.points[0].y, stroke.size/2, 0, Math.PI*2);
                                ctx.fill();
                             }
                             return;
                        }
                        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                        for (let i = 1; i < stroke.points.length; i++) {
                            ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                        }
                        break;
                    case 'line':
                        if (stroke.points.length < 2) return;
                        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                        ctx.lineTo(stroke.points[1].x, stroke.points[1].y);
                        break;
                    case 'rect':
                        if (stroke.points.length < 2) return;
                        const p1 = stroke.points[0];
                        const p2 = stroke.points[1];
                        ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                        break;
                    case 'circle':
                        if (stroke.points.length < 2) return;
                        const center = stroke.points[0];
                        const edge = stroke.points[1];
                        const radius = Math.sqrt(Math.pow(edge.x - center.x, 2) + Math.pow(edge.y - center.y, 2));
                        ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
                        break;
                    case 'triangle':
                        if (stroke.points.length < 2) return;
                        const pA = stroke.points[0];
                        const pB = stroke.points[1];
                        ctx.moveTo(pA.x, pA.y);
                        ctx.lineTo(pA.x, pB.y);
                        ctx.lineTo(pB.x, pB.y);
                        ctx.closePath();
                        break;
                }
                ctx.stroke();
            }

            // --- Main Render Loop ---
            function render() {
                if (!ctx) return;
                
                // CRITICAL FIX: Reset transform to identity then clear using physical pixels
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // CRITICAL FIX: Scale by Device Pixel Ratio for crisp text/lines
                // If dpr is weird, default to 1
                if(isNaN(dpr) || dpr <= 0) dpr = 1;
                ctx.scale(dpr, dpr);

                drawBackground();
                
                ctx.save();
                ctx.translate(viewOffset.x, viewOffset.y);
                ctx.scale(viewZoom, viewZoom);
                
                strokes.forEach(drawStroke);
                if (currentPath) {
                    drawStroke(currentPath);
                }
                ctx.restore();
            }

            // --- Object Eraser Logic ---
            function getDistance(p1, p2) {
                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            }
            function isPointNearStroke(worldPoint, stroke) {
                // Handle text
                if (stroke.type === 'text') {
                    // Better bounding box for text with multi-line support
                    const fontSize = stroke.fontSize || 16;
                    const lines = stroke.text.split('\n');
                    const lineHeight = fontSize * 1.2;
                    const totalHeight = lines.length * lineHeight;
                    
                    // Estimate text width (use longest line)
                    const maxLineLength = Math.max(...lines.map(l => l.length));
                    const textWidth = maxLineLength * fontSize * 0.6; // Approximate
                    
                    return (worldPoint.x >= stroke.x - 10 && worldPoint.x <= stroke.x + textWidth + 10 &&
                            worldPoint.y >= stroke.y - fontSize && worldPoint.y <= stroke.y + totalHeight);
                }
                
                const screenPixelTolerance = 5 / viewZoom; 
                const tolerance = (currentEraserMode === 'object' ? currentEraserSize : stroke.size) + screenPixelTolerance;
                switch (stroke.tool) {
                    case 'pen':
                        return stroke.points.some(p => getDistance(worldPoint, p) < tolerance);
                    case 'line':
                    case 'rect':
                    case 'circle':
                    case 'triangle':
                        const p1 = stroke.points[0];
                        const p2 = stroke.points[1];
                        const minX = Math.min(p1.x, p2.x) - tolerance;
                        const maxX = Math.max(p1.x, p2.x) + tolerance;
                        const minY = Math.min(p1.y, p2.y) - tolerance;
                        const maxY = Math.max(p1.y, p2.y) + tolerance;
                        if (stroke.tool === 'circle') {
                            const center = stroke.points[0];
                            const radius = getDistance(stroke.points[0], stroke.points[1]);
                            const distToCenter = getDistance(worldPoint, center);
                            return Math.abs(distToCenter - radius) < tolerance;
                        }
                        return (worldPoint.x >= minX && worldPoint.x <= maxX &&
                                worldPoint.y >= minY && worldPoint.y <= maxY);
                }
                return false;
            }
            function findAndRemoveStroke(worldPoint) {
                let didDelete = false;
                for (let i = strokes.length - 1; i >= 0; i--) {
                    if (isPointNearStroke(worldPoint, strokes[i])) {
                        strokes.splice(i, 1);
                        didDelete = true;
                        break; 
                    }
                }
                if (didDelete) {
                    render();
                }
                return didDelete;
            }

            // --- Drawing Functions ---
            function getCoords(e) {
                return { x: e.clientX, y: e.clientY };
            }
            
            function startDrawing(e) {
                // If not drawing on canvas or overlay, ignore
                if(e.target !== canvas) return;

                if (toolbarWrapper.classList.contains('sticky-expand')) {
                    toolbarWrapper.classList.remove('sticky-expand');
                    toolbarWrapper.classList.add('compact-mode');
                }
                penPopover.classList.remove('active');
                eraserPopover.classList.remove('active');
                canvasPopover.classList.remove('active');
                
                if (e.target.closest('#toolbar-wrapper') || isTwoFingerPanning) {
                    return;
                }
                
                // Text tool handling
                if (currentTool === 'text') {
                    const { x: screenX, y: screenY } = getCoords(e);
                    const worldPoint = screenToWorld(screenX, screenY);
                    textInputOverlay.dataset.x = worldPoint.x;
                    textInputOverlay.dataset.y = worldPoint.y;
                    textInputOverlay.style.left = screenX + 'px';
                    textInputOverlay.style.top = screenY + 'px';
                    textInputOverlay.classList.add('active');
                    textInput.focus();
                    return;
                }
                
                if (e.pointerType === 'touch') {
                    touchHoldTimer = setTimeout(() => {
                        isEraserGesture = true;
                        originalTool = currentTool;
                        currentTool = 'eraser';
                        
                        const { x: screenX, y: screenY } = getCoords(e);
                        const worldPoint = screenToWorld(screenX, screenY);
                        isDrawing = true;
                        addHistoryAction();
                        didDeleteInStroke = false;
                        if (findAndRemoveStroke(worldPoint)) {
                            didDeleteInStroke = true;
                        }

                    }, TOUCH_HOLD_DURATION);
                }
                
                if (isEraserGesture) return; 
                if (e.pointerType === 'mouse' && e.button !== 0) return;
                e.preventDefault();
                
                const { x: screenX, y: screenY } = getCoords(e);
                const worldPoint = screenToWorld(screenX, screenY);
                if (currentTool === 'pan') {
                    isPanning = true;
                    lastPanPos = { x: screenX, y: screenY };
                    canvas.classList.add('panning');
                    return;
                }
                isDrawing = true;
                if (currentTool === 'eraser') {
                    if (currentEraserMode === 'object') {
                        addHistoryAction();
                        didDeleteInStroke = false;
                        if (findAndRemoveStroke(worldPoint)) {
                            didDeleteInStroke = true;
                        }
                        return;
                    } else { // Pixel eraser
                        currentPath = { id: Date.now(), tool: 'pen', color: backgroundColor, size: currentEraserSize, points: [worldPoint] };
                        return; 
                    }
                }
                currentPath = { id: Date.now(), tool: currentTool, color: currentColor, size: currentBrushSize, points: [worldPoint] };
                if (['line', 'rect', 'circle', 'triangle'].includes(currentTool)) {
                    currentPath.points.push(worldPoint);
                }
            }
            
            function draw(e) {
                if (touchHoldTimer) {
                    clearTimeout(touchHoldTimer);
                    touchHoldTimer = null;
                }
                
                if ((!isDrawing && !isPanning) || isTwoFingerPanning) return;
                e.preventDefault();
                
                const { x: screenX, y: screenY } = getCoords(e);
                if (isPanning) {
                    const dx = screenX - lastPanPos.x;
                    const dy = screenY - lastPanPos.y;
                    viewOffset.x += dx;
                    viewOffset.y += dy;
                    lastPanPos = { x: screenX, y: screenY };
                    render();
                    return;
                }
                if (isDrawing) {
                    const worldPoint = screenToWorld(screenX, screenY);
                    if (currentTool === 'eraser') {
                        if (currentEraserMode === 'object') {
                            if (findAndRemoveStroke(worldPoint)) {
                                didDeleteInStroke = true;
                            }
                        } else { // Pixel eraser
                            if (currentPath) {
                                currentPath.points.push(worldPoint);
                                render();
                            }
                        }
                        return;
                    }
                    if (currentPath) {
                        switch (currentTool) {
                            case 'pen':
                                currentPath.points.push(worldPoint);
                                break;
                            case 'line':
                            case 'rect':
                            case 'circle':
                            case 'triangle':
                                currentPath.points[1] = worldPoint;
                                break;
                        }
                        render();
                    }
                }
            }

            function stopDrawing() {
                if (touchHoldTimer) {
                    clearTimeout(touchHoldTimer);
                    touchHoldTimer = null;
                }

                if (isPanning) {
                    isPanning = false;
                    canvas.classList.remove('panning');
                    saveViewTransform(); 
                }
                if (isDrawing) {
                    isDrawing = false;
                    let didChange = false;
                    if (currentTool === 'eraser') {
                        if (currentEraserMode === 'object') {
                            if (didDeleteInStroke) {
                                didChange = true;
                            }
                            didDeleteInStroke = false;
                        } else { // Pixel eraser
                            if (currentPath && currentPath.points.length > 0) {
                                 if(currentPath.points.length === 1) {
                                    // Extend slighty so single click eraser works
                                    currentPath.points.push({x: currentPath.points[0].x+0.1, y: currentPath.points[0].y+0.1});
                                 }
                                addHistoryAction();
                                strokes.push(currentPath);
                                didChange = true;
                            } 
                            currentPath = null;
                        }
                    } else if (currentPath) {
                        if (currentPath.tool === 'pen' && currentPath.points.length === 1) {
                            currentPath.points.push({ x: currentPath.points[0].x + (0.1 / viewZoom), y: currentPath.points[0].y + (0.1 / viewZoom) });
                        }
                        if (currentPath.points.length > 1) {
                            addHistoryAction();
                            strokes.push(currentPath);
                            didChange = true;
                        }
                        currentPath = null;
                    }
                    
                    if (didChange) {
                        render();
                        saveStrokesAndSettings(); 
                    }
                }
                
                if (isEraserGesture) {
                    isEraserGesture = false;
                    currentTool = originalTool;
                }
            }

            // --- Toolbar Event Listeners ---
            function updateActiveToolButton(activeTool) {
                toolButtons.forEach(btn => {
                    if (btn.tool === activeTool) {
                        btn.el.classList.add('active');
                    } else {
                        btn.el.classList.remove('active');
                    }
                });
                if (activeTool === 'pan') {
                    canvas.style.cursor = 'grab';
                    canvas.classList.add('panning');
                } else {
                    // Changed from none to crosshair for safety if custom cursor fails
                    canvas.style.cursor = 'crosshair'; 
                    canvas.classList.remove('panning');
                }
                customCursorCircle.style.display = 'none';
                customCursorEraser.style.display = 'none';
            }
            
            function positionPopover(popover, buttonRect) {
                const popoverWidth = popover.offsetWidth;
                let top = buttonRect.bottom + 12; 
                let left = buttonRect.left + (buttonRect.width / 2) - (popoverWidth / 2);
                left = Math.max(16, left);
                if (left + popoverWidth > window.innerWidth - 16) {
                    left = window.innerWidth - 16 - popoverWidth;
                }
                popover.style.top = `${top}px`;
                popover.style.left = `${left}px`;
                popover.style.transform = 'none';
            }
            
            penBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const wasActive = penPopover.classList.contains('active');
                eraserPopover.classList.remove('active');
                canvasPopover.classList.remove('active');
                if (wasActive) {
                    penPopover.classList.remove('active');
                } else {
                    penPopover.classList.add('active');
                    // Temporarily display to calculate width
                    penPopover.style.display = 'block';
                    const btnRect = penBtn.getBoundingClientRect();
                    positionPopover(penPopover, btnRect);
                    // Let CSS handle display state via class
                    penPopover.style.display = ''; 
                }
                currentTool = 'pen';
                originalTool = 'pen';
                updateActiveToolButton('pen');
            });
            
            eraserBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const wasActive = eraserPopover.classList.contains('active');
                penPopover.classList.remove('active');
                canvasPopover.classList.remove('active');
                if (wasActive) {
                    eraserPopover.classList.remove('active');
                } else {
                    eraserPopover.classList.add('active');
                    eraserPopover.style.display = 'block';
                    const btnRect = eraserBtn.getBoundingClientRect();
                    positionPopover(eraserPopover, btnRect);
                    eraserPopover.style.display = '';
                }
                currentTool = 'eraser';
                originalTool = 'eraser';
                updateActiveToolButton('eraser');
            });
            
            // Text tool handler
            if (textBtn) {
                textBtn.addEventListener('click', () => {
                    currentTool = 'text';
                    originalTool = 'text';
                    updateActiveToolButton('text');
                    penPopover.classList.remove('active');
                    eraserPopover.classList.remove('active');
                    canvasPopover.classList.remove('active');
                });
            }
            
            // Text formatting button handlers
            if (textBoldBtn) {
                textBoldBtn.addEventListener('click', () => {
                    textBold = !textBold;
                    textBoldBtn.classList.toggle('active', textBold);
                    updateTextInputStyle();
                });
            }
            
            if (textItalicBtn) {
                textItalicBtn.addEventListener('click', () => {
                    textItalic = !textItalic;
                    textItalicBtn.classList.toggle('active', textItalic);
                    updateTextInputStyle();
                });
            }
            
            if (textUnderlineBtn) {
                textUnderlineBtn.addEventListener('click', () => {
                    textUnderline = !textUnderline;
                    textUnderlineBtn.classList.toggle('active', textUnderline);
                    updateTextInputStyle();
                });
            }
            
            // Update textarea style based on formatting
            function updateTextInputStyle() {
                if (textInput) {
                    textInput.style.fontWeight = textBold ? 'bold' : 'normal';
                    textInput.style.fontStyle = textItalic ? 'italic' : 'normal';
                    textInput.style.textDecoration = textUnderline ? 'underline' : 'none';
                    textInput.style.fontFamily = textFontFamily.value;
                    textInput.style.fontSize = textFontSize.value + 'px';
                }
            }
            
            // Font family change handler
            if (textFontFamily) {
                textFontFamily.addEventListener('change', updateTextInputStyle);
            }
            
            // Font size change handler
            if (textFontSize) {
                textFontSize.addEventListener('change', updateTextInputStyle);
            }
            
            // Function to add text to canvas
            function addTextToCanvas() {
                if (textInput && textInput.value.trim()) {
                    const textData = {
                        type: 'text',
                        text: textInput.value,
                        x: parseFloat(textInputOverlay.dataset.x),
                        y: parseFloat(textInputOverlay.dataset.y),
                        color: currentColor,
                        fontSize: parseInt(textFontSize.value),
                        fontFamily: textFontFamily.value,
                        bold: textBold,
                        italic: textItalic,
                        underline: textUnderline,
                    };
                    strokes.push(textData);
                    addHistoryAction();
                    render();
                    autosave();
                }
                closeTextInput();
            }
            
            // Function to close text input
            function closeTextInput() {
                textInputOverlay.classList.remove('active');
                textInput.value = '';
                textBold = false;
                textItalic = false;
                textUnderline = false;
                textBoldBtn.classList.remove('active');
                textItalicBtn.classList.remove('active');
                textUnderlineBtn.classList.remove('active');
            }
            
            // Text submit button
            if (textSubmitBtn) {
                textSubmitBtn.addEventListener('click', addTextToCanvas);
            }
            
            // Text cancel button
            if (textCancelBtn) {
                textCancelBtn.addEventListener('click', closeTextInput);
            }
            
            // Text input handling with keyboard shortcuts
            if (textInput) {
                textInput.addEventListener('keydown', (e) => {
                    // Ctrl+B for bold
                    if (e.ctrlKey && e.key === 'b') {
                        e.preventDefault();
                        textBoldBtn.click();
                    }
                    // Ctrl+I for italic
                    else if (e.ctrlKey && e.key === 'i') {
                        e.preventDefault();
                        textItalicBtn.click();
                    }
                    // Ctrl+U for underline
                    else if (e.ctrlKey && e.key === 'u') {
                        e.preventDefault();
                        textUnderlineBtn.click();
                    }
                    // Ctrl+Enter to submit
                    else if (e.ctrlKey && e.key === 'Enter') {
                        e.preventDefault();
                        addTextToCanvas();
                    }
                    // Escape to cancel
                    else if (e.key === 'Escape') {
                        closeTextInput();
                    }
                });
            }
            
            canvasBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const wasActive = canvasPopover.classList.contains('active');
                penPopover.classList.remove('active');
                eraserPopover.classList.remove('active');
                if (wasActive) {
                    canvasPopover.classList.remove('active');
                } else {
                    canvasPopover.classList.add('active');
                    canvasPopover.style.display = 'block';
                    const btnRect = canvasBtn.getBoundingClientRect();
                    positionPopover(canvasPopover, btnRect);
                    canvasPopover.style.display = '';
                }
            });

            [lineBtn, rectBtn, circleBtn, triangleBtn].forEach(btn => {
                btn.addEventListener('click', () => {
                    const tool = toolButtons.find(b => b.el === btn).tool;
                    currentTool = tool;
                    originalTool = tool;
                    updateActiveToolButton(tool);
                    penPopover.classList.remove('active');
                    eraserPopover.classList.remove('active');
                    canvasPopover.classList.remove('active');
                });
            });
            
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            colorPicker.addEventListener('input', (e) => {
                currentColor = e.target.value;
                penBtn.querySelector('svg').style.stroke = currentColor;
                penPreview.style.backgroundColor = currentColor;
            });
            
            function updatePenCursorSize() {
                // Adjust cursor size logic slightly to account for visual zoom
                const cursorSize = Math.max(4, (currentBrushSize * viewZoom));
                customCursorCircle.style.width = `${cursorSize}px`;
                customCursorCircle.style.height = `${cursorSize}px`;
            }
            
            function setupThicknessControl(controlEl) {
                const input = controlEl.querySelector('input[type="number"]');
                const decBtn = controlEl.querySelector('[data-action="decrease"]');
                const incBtn = controlEl.querySelector('[data-action="increase"]');
                const type = controlEl.dataset.type;
                const updateSize = (newSize) => {
                    newSize = Math.max(1, Math.min(newSize, 500));
                    input.value = newSize;
                    if (type === 'pen') {
                        currentBrushSize = newSize;
                        penSizeLabel.textContent = `${newSize}px`;
                        updatePenCursorSize();
                        penPreview.style.height = `${Math.min(currentBrushSize, 40)}px`;
                    } else { // eraser
                        currentEraserSize = newSize;
                        eraserSizeLabel.textContent = `${newSize}px`;
                        const previewSize = Math.min(currentEraserSize, 40);
                        eraserPreview.style.width = `${previewSize}px`;
                        eraserPreview.style.height = `${previewSize}px`;
                    }
                };
                input.addEventListener('input', () => updateSize(parseInt(input.value) || 1));
                input.addEventListener('change', () => updateSize(parseInt(input.value) || 1));
                decBtn.addEventListener('click', () => updateSize(parseInt(input.value) - 1));
                incBtn.addEventListener('click', () => updateSize(parseInt(input.value) + 1));
                updateSize(parseInt(input.value));
            }
            setupThicknessControl(penThicknessControl);
            setupThicknessControl(eraserThicknessControl);
            
            objectEraserBtn.addEventListener('click', () => {
                currentEraserMode = 'object';
                objectEraserBtn.classList.add('bg-blue-100', 'text-blue-700');
                objectEraserBtn.classList.remove('bg-white', 'text-gray-700', 'hover:bg-gray-50');
                pixelEraserBtn.classList.add('bg-white', 'text-gray-700', 'hover:bg-gray-50');
                pixelEraserBtn.classList.remove('bg-blue-100', 'text-blue-700');
            });
            pixelEraserBtn.addEventListener('click', () => {
                currentEraserMode = 'pixel';
                pixelEraserBtn.classList.add('bg-blue-100', 'text-blue-700');
                pixelEraserBtn.classList.remove('bg-white', 'text-gray-700', 'hover:bg-gray-50');
                objectEraserBtn.classList.add('bg-white', 'text-gray-700', 'hover:bg-gray-50');
                objectEraserBtn.classList.remove('bg-blue-100', 'text-blue-700');
            });

            bgColorPicker.addEventListener('input', (e) => {
                backgroundColor = e.target.value;
                updateCanvasIconPreview();
                render();
                saveStrokesAndSettings();
            });
            
            bgPatternSelector.addEventListener('change', (e) => {
                backgroundPattern = e.target.value;
                updateCanvasIconPreview();
                render();
                saveStrokesAndSettings();
            });

            clearBtn.addEventListener('click', () => {
                confirmModal.classList.remove('hidden');
            });
            cancelClearBtn.addEventListener('click', () => {
                confirmModal.classList.add('hidden');
            });
            confirmClearBtn.addEventListener('click', () => {
                if (strokes.length > 0) {
                    addHistoryAction();
                }
                strokes = [];
                viewOffset = { x: 0, y: 0 };
                viewZoom = 1; 
                render();
                saveStrokesAndSettings(); 
                saveViewTransform();
                confirmModal.classList.add('hidden');
            });
            
            document.addEventListener('pointerdown', (e) => {
                if (!e.target.closest('#toolbar-wrapper') && !e.target.closest('.popover') && !e.target.closest('#buttonDiv') && !e.target.closest('#authStatus') && !e.target.closest('#save-drawing-btn')) {
                    penPopover.classList.remove('active');
                    eraserPopover.classList.remove('active');
                    canvasPopover.classList.remove('active');
                    if (!toolbarWrapper.classList.contains('sticky-expand')) {
                        toolbarWrapper.classList.add('compact-mode');
                    }
                }
            });

            // --- Main Event Listeners ---
            
            function handlePointerDown(e) {
                startDrawing(e);
            }
            function handlePointerUp() {
                stopDrawing();
            }
            canvas.addEventListener('pointerdown', handlePointerDown);
            document.addEventListener('pointermove', draw);
            document.addEventListener('pointerup', handlePointerUp);
            document.addEventListener('pointercancel', handlePointerUp);
            
            // Touch events for 2-finger pan AND zoom
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault(); 
                    isTwoFingerPanning = true;
                    isDrawing = false; 
                    isPanning = false; 
                    
                    lastTouchMidpoint = {
                        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                        y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
                    };
                    lastTouchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                if (isTwoFingerPanning && e.touches.length === 2) {
                    e.preventDefault();
                    
                    // Pan
                    const newMidpoint = {
                        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                        y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
                    };
                    const deltaX = newMidpoint.x - lastTouchMidpoint.x;
                    const deltaY = newMidpoint.y - lastTouchMidpoint.y;
                    viewOffset.x += deltaX;
                    viewOffset.y += deltaY;
                    lastTouchMidpoint = newMidpoint;
                    
                    // Zoom
                    const newTouchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const deltaDistance = newTouchDistance - lastTouchDistance;
                    
                    // Use a slower zoom factor for touch
                    const zoomFactor = 1 + (deltaDistance / 100) * (ZOOM_STEP * 5);
                    const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewZoom * zoomFactor));
                    
                    const screenX = newMidpoint.x;
                    const screenY = newMidpoint.y;
                    const worldPoint = screenToWorld(screenX, screenY);
                    viewZoom = newZoom;
                    
                    // Adjust offset to zoom into center
                    viewOffset.x = screenX - worldPoint.x * viewZoom;
                    viewOffset.y = screenY - worldPoint.y * viewZoom;

                    lastTouchDistance = newTouchDistance;
                    updatePenCursorSize();
                    
                    render();
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                if (isTwoFingerPanning) {
                    isTwoFingerPanning = false;
                    saveViewTransform(); 
                }
            });

            canvas.addEventListener('wheel', (e) => {
                if (e.target.closest('#toolbar-wrapper')) return;
                e.preventDefault();
                if (e.ctrlKey) {
                    // Zoom
                    const delta = -Math.sign(e.deltaY) * ZOOM_STEP;
                    const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewZoom + delta));
                    const screenX = e.clientX;
                    const screenY = e.clientY;
                    const worldPoint = screenToWorld(screenX, screenY);
                    viewZoom = newZoom;
                    viewOffset.x = screenX - worldPoint.x * viewZoom;
                    viewOffset.y = screenY - worldPoint.y * viewZoom;
                    updatePenCursorSize();
                } else {
                    // Pan
                    viewOffset.x -= e.deltaX;
                    viewOffset.y -= e.deltaY;
                }
                render();
                if (wheelSaveTimer) {
                    clearTimeout(wheelSaveTimer);
                }
                wheelSaveTimer = setTimeout(() => {
                    saveViewTransform(); 
                    wheelSaveTimer = null;
                }, 500);
            }, { passive: false });

            // --- Custom Cursor Logic ---
            document.addEventListener('pointermove', (e) => {
                const clientX = e.clientX;
                const clientY = e.clientY;
                customCursorCircle.style.left = `${clientX}px`;
                customCursorCircle.style.top = `${clientY}px`;
                customCursorEraser.style.left = `${clientX}px`;
                customCursorEraser.style.top = `${clientY}px`;

                if (e.pointerType === 'mouse') {
                    if (e.target === canvas) {
                        if (currentTool === 'eraser') {
                            customCursorCircle.style.display = 'none';
                            customCursorEraser.style.display = 'block';
                            canvas.style.cursor = 'none';
                        } else if (currentTool !== 'pan') {
                            customCursorCircle.style.display = 'block';
                            customCursorEraser.style.display = 'none';
                            canvas.style.cursor = 'none';
                        } else { 
                            customCursorCircle.style.display = 'none';
                            customCursorEraser.style.display = 'none';
                        }
                    } else {
                        customCursorCircle.style.display = 'none';
                        customCursorEraser.style.display = 'none';
                    }
                } else {
                    customCursorCircle.style.display = 'none';
                    customCursorEraser.style.display = 'none';
                }
            });
            
            document.addEventListener('mouseleave', () => {
                customCursorCircle.style.display = 'none';
                customCursorEraser.style.display = 'none';
            });
            
            // --- Keyboard Shortcuts ---
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;

                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z') {
                        e.preventDefault();
                        undo();
                    } else if (e.key === 'y') {
                        e.preventDefault();
                        redo();
                    }
                } else if (e.key === '1') {
                    e.preventDefault();
                    currentTool = 'pen';
                    originalTool = 'pen';
                    updateActiveToolButton('pen');
                    eraserPopover.classList.remove('active');
                    canvasPopover.classList.remove('active');
                } else if (e.key === '2') {
                    e.preventDefault();
                    currentTool = 'eraser';
                    originalTool = 'eraser';
                    updateActiveToolButton('eraser');
                    penPopover.classList.remove('active');
                    canvasPopover.classList.remove('active');
                } else if (e.key === '3') {
                    e.preventDefault();
                    currentTool = 'text';
                    originalTool = 'text';
                    updateActiveToolButton('text');
                    penPopover.classList.remove('active');
                    eraserPopover.classList.remove('active');
                    canvasPopover.classList.remove('active');
                } else if (e.key === 'Delete') {
                    e.preventDefault();
                    confirmModal.classList.remove('hidden');
                }
            });
            
            // --- Toolbar Expand/Shrink Logic ---
            toolbarWrapper.addEventListener('mouseenter', () => {
                toolbarWrapper.classList.remove('compact-mode');
            });
            toolbarWrapper.addEventListener('mouseleave', () => {
                if (!toolbarWrapper.classList.contains('sticky-expand')) {
                    toolbarWrapper.classList.add('compact-mode');
                }
            });
            toolbarWrapper.addEventListener('pointerdown', (e) => {
                toolbarWrapper.classList.add('sticky-expand');
                e.stopPropagation(); 
            });

            // --- Initialization ---
            
            // Must call resize ONCE at startup to set correct pixel ratio
            resizeCanvas();
            loadFromStorage();
            updateActiveToolButton(currentTool); 
            updateUndoRedoButtons(); 

            // Set initial UI values
            penThicknessInput.value = currentBrushSize;
            penSizeLabel.textContent = `${currentBrushSize}px`;
            eraserThicknessInput.value = currentEraserSize;
            eraserSizeLabel.textContent = `${currentEraserSize}px`;
            penBtn.querySelector('svg').style.stroke = currentColor;
            penPreview.style.backgroundColor = currentColor;
            penPreview.style.height = `${Math.min(currentBrushSize, 40)}px`;
            const eraserPreviewSize = Math.min(currentEraserSize, 40);
            eraserPreview.style.width = `${eraserPreviewSize}px`;
            eraserPreview.style.height = `${eraserPreviewSize}px`;


            window.addEventListener('resize', resizeCanvas);
            
            // Expose function to get current drawing data for saving
            window.getDrawingData = function() {
                return {
                    strokes: strokes,
                    backgroundColor: backgroundColor,
                    backgroundPattern: backgroundPattern,
                    viewOffset: viewOffset,
                    viewZoom: viewZoom
                };
            };
            
            // Expose function to load drawing data from saved file
            window.loadDrawingData = function(data) {
                if (!data) return;
                
                // Clear current drawing
                strokes = [];
                undoStack = [];
                redoStack = [];
                
                // Load strokes
                if (data.strokes && Array.isArray(data.strokes)) {
                    strokes = data.strokes;
                }
                
                // Load background settings
                if (data.backgroundColor) {
                    backgroundColor = data.backgroundColor;
                    bgColorPicker.value = backgroundColor;
                    updateCanvasIconPreview();
                }
                
                if (data.backgroundPattern) {
                    backgroundPattern = data.backgroundPattern;
                    bgPatternSelector.value = backgroundPattern;
                    updateCanvasIconPreview();
                }
                
                // Load view settings
                if (data.viewOffset) {
                    viewOffset = data.viewOffset;
                }
                
                if (data.viewZoom) {
                    viewZoom = data.viewZoom;
                }
                
                // Re-render the canvas
                render();
                updateUndoRedoButtons();
            };

        } catch (criticalError) {
            console.error("Critical Initialization Error:", criticalError);
            const errorBox = document.getElementById('global-error-box');
            if(errorBox) {
                errorBox.style.display = 'block';
                errorBox.innerHTML += `CRITICAL: ${criticalError.message}`;
            }
        }
    });
        
    </script>
</body>
</html>
