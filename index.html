<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebBoard- By Dhairya Shah</title>
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/Dcode9/whiteboard/dfcc6b7600fe1bf56dd763ea9715e9ad5363c227/WebBoard.png?v=2">
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        }
    </script>
    <style>
        /* Basic styles for a smooth experience */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevents scrolling */
            width: 100%;
            height: 100%;
        }
        /* The canvas itself */
        #whiteboard {
            display: block;
            cursor: none; /* Hide default cursor */
        }
        
        #whiteboard.panning {
            cursor: grab;
        }

        #whiteboard.panning:active {
            cursor: grabbing;
        }

        /* MODIFIED: Renamed to custom-cursor-circle */
        #custom-cursor-circle {
            position: fixed;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            /* MODIFIED: Explicit styling as requested */
            background-color: white;
            border: 2px solid black; 
            border-radius: 50%;
            pointer-events: none; /* Let clicks pass through */
            transform: translate(-50%, -50%);
            /* REMOVED: mix-blend-mode: difference; */
            z-index: 9999;
            transition: width 0.1s ease, height 0.1s ease;
            display: none; /* Hide by default */
        }
        
        /* NEW: Eraser Cursor */
        #custom-cursor-eraser {
            position: fixed;
            top: 0;
            left: 0;
            width: 24px;
            height: 24px;
            pointer-events: none;
            /* Offset to make the "corner" of the eraser the pointer */
            transform: translate(-4px, -22px); 
            z-index: 9999;
            mix-blend-mode: difference;
            display: none; /* Hide by default */
        }
        
        #custom-cursor-eraser svg {
            width: 100%;
            height: 100%;
            /* Use white, mix-blend-mode will invert it against background */
            fill: white; 
            stroke: white;
            stroke-width: 1.5;
        }

        /* MODIFIED: Hide both custom cursors when panning */
        #whiteboard.panning + #custom-cursor-circle,
        #whiteboard.panning + #custom-cursor-eraser {
            display: none;
        }

        /* Style for the save indicator */
        #save-indicator {
            transition: opacity 0.5s ease-out;
        }
        
        /* Custom styles for color input */
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 3rem; /* 48px - Larger */
            height: 3rem; /* 48px - Larger */
            padding: 0;
            border: none;
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            background-color: transparent;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 0.375rem;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 2px solid #e2e8f0; /* gray-200 */
            border-radius: 0.375rem;
        }
        input[type="color"]::-moz-color-swatch {
            border: 2px solid #e2e8f0;
            border-radius: 0.375rem;
        }

        /* Style for active tool button */
        .tool-btn.active {
            background-color: #dbeafe; /* blue-100 */
            color: #2563eb; /* blue-600 */
            box-shadow: 0 0 0 2px #bfdbfe; /* blue-200 */
        }

        /* NEW: Larger touch targets for buttons */
        .tool-btn {
            padding: 0.75rem; /* p-3 */
            border-radius: 0.5rem; /* rounded-md */
        }
        .tool-btn svg {
            width: 1.75rem; /* w-7 */
            height: 1.75rem; /* h-7 */
            pointer-events: none;
        }
    </style>
</head>
<body class="font-sans antialiased">

    <!-- MODIFIED: "Floating" Toolbar -->
    <div id="toolbar" class="fixed top-4 left-1/2 -translate-x-1/2 bg-white rounded-lg shadow-xl p-3 flex items-center justify-center flex-nowrap gap-x-2 md:gap-x-4 z-10 select-none overflow-x-auto max-w-[95vw]">
        
        <!-- Color Picker -->
        <div class="flex flex-col items-center">
            <label for="color-picker" class="text-xs text-gray-500 mb-1">Brush</label>
            <input type="color" id="color-picker" value="#000000" title="Brush Color">
        </div>

        <!-- Pen Tool -->
        <div class="flex flex-col items-center">
            <label class="text-xs text-gray-500 mb-1 invisible">Tool</label>
            <button id="pen-btn" class="tool-btn rounded-md active" title="Pen">
                <!-- Lucide Pen icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                    <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>
                </svg>
            </button>
        </div>

        <!-- Pan Tool -->
        <div class="flex flex-col items-center">
            <label class="text-xs text-gray-500 mb-1 invisible">Tool</label>
            <button id="pan-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Pan (Move Canvas)">
                <!-- Lucide Hand icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                    <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/>
                    <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/>
                    <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/>
                    <path d="M18 8a2 2 0 0 0-2 2v10a4 4 0 0 1-4 4v0a4 4 0 0 1-4-4V6a2 2 0 0 1 2-2v0a2 2 0 0 1 2 2v0"/>
                </svg>
            </button>
        </div>

        <!-- Eraser Tool -->
        <div class="flex flex-col items-center">
            <label class="text-xs text-gray-500 mb-1 invisible">Tool</label>
            <button id="eraser-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Object Eraser">
                <!-- Lucide Eraser icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                    <path d="m19 21-7-7-4 4L2 12l9-9 4 4 7 7Z"/><path d="m18 11 4-4"/><path d="m14 15 4-4"/>
                </svg>
            </button>
        </div>

        <!-- Brush Size -->
        <div class="flex flex-col items-center">
            <label for="brush-size" class="text-xs text-gray-500 mb-1">Size (<span id="brush-size-label" class="w-4 inline-block">5</span>)</label>
            <input type="range" id="brush-size" min="1" max="100" value="5" class="w-20 md:w-32 cursor-pointer">
        </div>

        <!-- Line Tool -->
        <div class="flex flex-col items-center">
            <label class="text-xs text-gray-500 mb-1 invisible">Shape</label>
            <button id="line-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Line">
                <!-- Lucide Minus icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
            </button>
        </div>
        
        <!-- Rectangle Tool -->
        <div class="flex flex-col items-center">
            <label class="text-xs text-gray-500 mb-1 invisible">Shape</label>
            <button id="rect-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Rectangle">
                <!-- Lucide Square icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                </svg>
            </button>
        </div>

        <!-- Circle Tool -->
        <div class="flex flex-col items-center">
            <label class="text-xs text-gray-500 mb-1 invisible">Shape</label>
            <button id="circle-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Circle">
                <!-- Lucide Circle icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                    <circle cx="12" cy="12" r="10"></circle>
                </svg>
            </button>
        </div>

        <!-- Triangle Tool -->
        <div class="flex flex-col items-center">
            <label class="text-xs text-gray-500 mb-1 invisible">Shape</label>
            <button id="triangle-btn" class="tool-btn rounded-md hover:bg-gray-200" title="Triangle">
                <!-- Lucide Triangle icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7 pointer-events-none">
                    <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                </svg>
            </button>
        </div>

        <!-- Background Color -->
        <div class="flex flex-col items-center">
            <label for="bg-color-picker" class="text-xs text-gray-500 mb-1">BG</label>
            <input type="color" id="bg-color-picker" value="#FFFFFF" title="Background Color (for new canvas)">
        </div>

        <!-- Background Pattern -->
        <div class="flex flex-col items-center">
            <label for="bg-pattern" class="text-xs text-gray-500 mb-1">Pattern</label>
            <select id="bg-pattern" class="text-sm border border-gray-300 rounded-md p-1 h-12 w-24" title="Background Pattern (for new canvas)">
                <option value="plain">Plain</option>
                <option value="ruled">Ruled</option>
                <option value="grid">Grid</option>
            </select>
        </div>

        <!-- Clear Canvas -->
        <div class="flex flex-col items-center">
            <label class="text-xs text-gray-500 mb-1 invisible">Action</label>
            <button id="clear-btn" class="tool-btn rounded-md hover:bg-red-100 text-red-600" title="Clear Canvas">
                <!-- Lucide Trash 2 icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7">
                    <path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/>
                </svg>
            </button>
        </div>
    </div>

    <!-- Save Indicator -->
    <div id="save-indicator" class="fixed bottom-4 right-4 bg-green-600 text-white text-sm px-3 py-1 rounded-full shadow-lg opacity-0 select-none">
        Saved!
    </div>

    <!-- Confirmation Modal (hidden by default) -->
    <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl w-11/12 max-w-sm">
            <h3 class="text-lg font-medium mb-4">Clear Canvas?</h3>
            <p class="text-sm text-gray-600 mb-6">This will permanently erase all drawings. This action cannot be undone.</p>
            <div class="flex justify-end space-x-3">
                <button id="cancel-clear" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Cancel</button>
                <button id="confirm-clear" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">Clear</button>
            </div>
        </div>
    </div>

    <!-- Drawing Area -->
    <canvas id="whiteboard"></canvas>
    
    <!-- MODIFIED: Renamed -->
    <div id="custom-cursor-circle"></div>
    <!-- NEW: Eraser Cursor Element -->
    <div id="custom-cursor-eraser">
        <!-- Lucide Eraser icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="m19 21-7-7-4 4L2 12l9-9 4 4 7 7Z"/><path d="m18 11 4-4"/>
        </svg>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('whiteboard');
            const ctx = canvas.getContext('2d');
            const toolbar = document.getElementById('toolbar');
            // MODIFIED: Get both cursors
            const customCursorCircle = document.getElementById('custom-cursor-circle');
            const customCursorEraser = document.getElementById('custom-cursor-eraser');

            // Toolbar controls
            const colorPicker = document.getElementById('color-picker');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeLabel = document.getElementById('brush-size-label');
            const clearBtn = document.getElementById('clear-btn');
            
            // Tool buttons
            const toolButtons = [
                { el: document.getElementById('pen-btn'), tool: 'pen' },
                { el: document.getElementById('pan-btn'), tool: 'pan' },
                { el: document.getElementById('eraser-btn'), tool: 'eraser' },
                { el: document.getElementById('line-btn'), tool: 'line' },
                { el: document.getElementById('rect-btn'), tool: 'rect' },
                { el: document.getElementById('circle-btn'), tool: 'circle' },
                { el: document.getElementById('triangle-btn'), tool: 'triangle' },
            ];

            // Background controls
            const bgColorPicker = document.getElementById('bg-color-picker');
            const bgPatternSelector = document.getElementById('bg-pattern');
            
            // Indicators & Modals
            const saveIndicator = document.getElementById('save-indicator');
            const confirmModal = document.getElementById('confirm-modal');
            const cancelClearBtn = document.getElementById('cancel-clear');
            const confirmClearBtn = document.getElementById('confirm-clear');

            // --- STATE ---
            let strokes = []; // The "source of truth" for all drawings
            let currentPath = null; // The path currently being drawn
            let viewOffset = { x: 0, y: 0 }; // Pan offset
            let lastPanPos = { x: 0, y: 0 };
            
            let isDrawing = false;
            let isPanning = false;
            let didDeleteInStroke = false; // For drag-to-erase
            let wheelSaveTimer = null; // Timer for wheel save

            let currentColor = '#000000';
            let currentBrushSize = 5;
            let currentTool = 'pen'; // 'pen', 'eraser', 'line', 'rect', 'circle', 'triangle', 'pan'
            
            let backgroundColor = '#FFFFFF';
            let backgroundPattern = 'plain'; // 'plain', 'ruled', 'grid'

            // REMOVED: State for cursor visibility
            // let isMouseOnCanvas = false;

            // --- Coordinate Conversion ---
            function screenToWorld(screenX, screenY) {
                return { x: screenX - viewOffset.x, y: screenY - viewOffset.y };
            }
            
            function worldToScreen(worldX, worldY) {
                return { x: worldX + viewOffset.x, y: worldY + viewOffset.y };
            }

            // --- Canvas Setup ---
            
            function drawBackground() {
                // Fill background color
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw pattern
                if (backgroundPattern === 'plain') return;

                ctx.strokeStyle = '#E2E8F0'; // gray-200
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const lineSpacing = 30; // 30px
                
                // Calculate pattern start offset by pan
                const startX = viewOffset.x % lineSpacing;
                const startY = viewOffset.y % lineSpacing;

                if (backgroundPattern === 'ruled') {
                    for (let y = startY; y < canvas.height; y += lineSpacing) {
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                    }
                } else if (backgroundPattern === 'grid') {
                    for (let y = startY; y < canvas.height; y += lineSpacing) {
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                    }
                    for (let x = startX; x < canvas.width; x += lineSpacing) {
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                    }
                }
                ctx.stroke();
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                render(); // Re-draw everything on resize
            }

            // --- Local Storage ---
            function showSaveIndicator() {
                saveIndicator.style.opacity = '1';
                setTimeout(() => {
                    saveIndicator.style.opacity = '0';
                }, 1500);
            }

            function saveViewOffset() {
                try {
                    localStorage.setItem('whiteboardViewOffset', JSON.stringify(viewOffset));
                } catch (e) {
                    console.error("Error saving view offset to localStorage", e);
                }
            }

            function saveStrokesAndSettings() {
                try {
                    localStorage.setItem('whiteboardStrokes', JSON.stringify(strokes));
                    localStorage.setItem('whiteboardBgColor', backgroundColor);
                    localStorage.setItem('whiteboardBgPattern', backgroundPattern);
                    showSaveIndicator();
                } catch (e) {
                    console.error("Error saving to localStorage", e);
                }
            }

            function loadFromStorage() {
                // Load background settings
                backgroundColor = localStorage.getItem('whiteboardBgColor') || '#FFFFFF';
                backgroundPattern = localStorage.getItem('whiteboardBgPattern') || 'plain';
                
                // Update UI elements
                bgColorPicker.value = backgroundColor;
                bgPatternSelector.value = backgroundPattern;
                // REMOVED: updateCursorColor(backgroundColor); // Update cursor color

                // Load pan offset
                viewOffset = JSON.parse(localStorage.getItem('whiteboardViewOffset')) || { x: 0, y: 0 };
                
                // Load drawing
                const strokesData = localStorage.getItem('whiteboardStrokes');
                if (strokesData) {
                    strokes = JSON.parse(strokesData);
                }
                
                render();
            }

            // --- Shape Drawing Functions ---
            
            function drawStroke(stroke) {
                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = stroke.size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                
                switch (stroke.tool) {
                    case 'pen':
                        if (stroke.points.length < 2) return;
                        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                        for (let i = 1; i < stroke.points.length; i++) {
                            ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                        }
                        break;
                    case 'line':
                        if (stroke.points.length < 2) return;
                        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                        ctx.lineTo(stroke.points[1].x, stroke.points[1].y);
                        break;
                    case 'rect':
                        if (stroke.points.length < 2) return;
                        const p1 = stroke.points[0];
                        const p2 = stroke.points[1];
                        ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                        break;
                    case 'circle':
                        if (stroke.points.length < 2) return;
                        const center = stroke.points[0];
                        const edge = stroke.points[1];
                        const radius = Math.sqrt(Math.pow(edge.x - center.x, 2) + Math.pow(edge.y - center.y, 2));
                        ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
                        break;
                    case 'triangle':
                        if (stroke.points.length < 2) return;
                        const pA = stroke.points[0];
                        const pB = stroke.points[1];
                        ctx.moveTo(pA.x, pA.y);
                        ctx.lineTo(pB.x, pB.y);
                        ctx.lineTo(pA.x, pB.y);
                        ctx.closePath();
                        break;
                }
                
                ctx.stroke();
            }

            // --- Main Render Loop ---
            function render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
                ctx.save();
                ctx.translate(viewOffset.x, viewOffset.y);
                strokes.forEach(drawStroke);
                if (currentPath) {
                    drawStroke(currentPath);
                }
                ctx.restore();
            }

            // --- Object Eraser Logic ---
            
            function getDistance(p1, p2) {
                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            }

            function isPointNearStroke(worldPoint, stroke) {
                const tolerance = (stroke.size / 2) + 5; // 5px tolerance
                
                switch (stroke.tool) {
                    case 'pen':
                        return stroke.points.some(p => getDistance(worldPoint, p) < tolerance);
                    
                    case 'line':
                    case 'rect':
                    case 'circle':
                    case 'triangle':
                        const p1 = stroke.points[0];
                        const p2 = stroke.points[1];
                        const minX = Math.min(p1.x, p2.x) - tolerance;
                        const maxX = Math.max(p1.x, p2.x) + tolerance;
                        const minY = Math.min(p1.y, p2.y) - tolerance;
                        const maxY = Math.max(p1.y, p2.y) + tolerance;

                        if (stroke.tool === 'circle') {
                            const center = stroke.points[0];
                            const radius = getDistance(stroke.points[0], stroke.points[1]);
                            const distToCenter = getDistance(worldPoint, center);
                            return Math.abs(distToCenter - radius) < tolerance;
                        }

                        return (worldPoint.x >= minX && worldPoint.x <= maxX &&
                                worldPoint.y >= minY && worldPoint.y <= maxY);
                }
                return false;
            }

            function findAndRemoveStroke(worldPoint) {
                let didDelete = false;
                for (let i = strokes.length - 1; i >= 0; i--) {
                    if (isPointNearStroke(worldPoint, strokes[i])) {
                        strokes.splice(i, 1);
                        didDelete = true;
                        break;
                    }
                }
                if (didDelete) {
                    render();
                }
                return didDelete;
            }

            // --- Drawing Functions ---
            
            function getCoords(e) {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            }

            function startDrawing(e) {
                if (e.target.closest('#toolbar')) return;
                e.preventDefault();
                
                const { x: screenX, y: screenY } = getCoords(e);
                const worldPoint = screenToWorld(screenX, screenY);

                if (currentTool === 'pan') {
                    isPanning = true;
                    lastPanPos = { x: screenX, y: screenY };
                    canvas.classList.add('panning');
                    return;
                }

                isDrawing = true;

                if (currentTool === 'eraser') {
                    didDeleteInStroke = false;
                    if (findAndRemoveStroke(worldPoint)) {
                        didDeleteInStroke = true;
                    }
                    return;
                }
                
                currentPath = {
                    id: Date.now(),
                    tool: currentTool,
                    color: currentColor,
                    size: currentBrushSize,
                    points: [worldPoint]
                };

                if (['line', 'rect', 'circle', 'triangle'].includes(currentTool)) {
                    currentPath.points.push(worldPoint);
                }
            }

            function draw(e) {
                if (!isDrawing && !isPanning) return;
                e.preventDefault();
                const { x: screenX, y: screenY } = getCoords(e);

                if (isPanning) {
                    const dx = screenX - lastPanPos.x;
                    const dy = screenY - lastPanPos.y;
                    viewOffset.x += dx;
                    viewOffset.y += dy;
                    lastPanPos = { x: screenX, y: screenY };
                    render();
                    return;
                }

                if (isDrawing) {
                    const worldPoint = screenToWorld(screenX, screenY);

                    if (currentTool === 'eraser') {
                        if (findAndRemoveStroke(worldPoint)) {
                            didDeleteInStroke = true;
                        }
                        return;
                    }
                    
                    if (currentPath) {
                        switch (currentTool) {
                            case 'pen':
                                currentPath.points.push(worldPoint);
                                break;
                            case 'line':
                            case 'rect':
                            case 'circle':
                            case 'triangle':
                                currentPath.points[1] = worldPoint;
                                break;
                        }
                        render();
                    }
                }
            }

            function stopDrawing() {
                if (isPanning) {
                    isPanning = false;
                    canvas.classList.remove('panning');
                    saveViewOffset();
                    showSaveIndicator();
                }

                if (isDrawing) {
                    isDrawing = false;
                    
                    if (currentTool === 'eraser') {
                        if (didDeleteInStroke) {
                            saveStrokesAndSettings();
                        }
                        didDeleteInStroke = false;
                        return;
                    }

                    if (currentPath) {
                        if (currentPath.points.length > 1 || currentPath.tool === 'pen') {
                            strokes.push(currentPath);
                        }
                        currentPath = null;
                        saveStrokesAndSettings();
                    }
                }
            }

            // --- Toolbar Event Listeners ---
            
            // MODIFIED: Centralized cursor logic
            function updateActiveToolButton(activeTool) {
                toolButtons.forEach(btn => {
                    if (btn.tool === activeTool) {
                        btn.el.classList.add('active');
                    } else {
                        btn.el.classList.remove('active');
                    }
                });
                
                // Set native cursor
                if (activeTool === 'pan') {
                    canvas.style.cursor = 'grab';
                    canvas.classList.add('panning');
                } else {
                    canvas.style.cursor = 'none';
                    canvas.classList.remove('panning');
                }
                
                // Update custom cursor visibility
                // REMOVED: updateCursorVisibility();
                
                // NEW: Hide both cursors. Mousemove will show the correct one.
                customCursorCircle.style.display = 'none';
                customCursorEraser.style.display = 'none';
            }

            toolButtons.forEach(btn => {
                btn.el.addEventListener('click', () => {
                    currentTool = btn.tool;
                    updateActiveToolButton(currentTool);
                });
            });

            // Color Picker
            colorPicker.addEventListener('input', (e) => {
                currentColor = e.target.value;
            });
            
            // MODIFIED: Brush Size (updates circle cursor)
            brushSizeSlider.addEventListener('input', (e) => {
                currentBrushSize = e.target.value;
                brushSizeLabel.textContent = currentBrushSize;
                const cursorSize = Math.max(10, currentBrushSize / 2);
                customCursorCircle.style.width = `${cursorSize}px`;
                customCursorCircle.style.height = `${cursorSize}px`;
            });

            // MODIFIED: Background Color Picker
            bgColorPicker.addEventListener('input', (e) => {
                backgroundColor = e.target.value;
                // REMOVED: updateCursorColor(backgroundColor);
                render();
                saveStrokesAndSettings();
            });

            // Background Pattern Selector
            bgPatternSelector.addEventListener('change', (e) => {
                backgroundPattern = e.target.value;
                render();
                saveStrokesAndSettings();
            });

            // Clear Button
            clearBtn.addEventListener('click', () => {
                confirmModal.classList.remove('hidden');
            });
            cancelClearBtn.addEventListener('click', () => {
                confirmModal.classList.add('hidden');
            });
            confirmClearBtn.addEventListener('click', () => {
                strokes = [];
                viewOffset = { x: 0, y: 0 };
                render();
                saveStrokesAndSettings();
                saveViewOffset();
                confirmModal.classList.add('hidden');
            });

            // --- Main Event Listeners ---
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing);

            canvas.addEventListener('wheel', (e) => {
                if (e.target.closest('#toolbar')) {
                    return;
                }
                e.preventDefault();
                viewOffset.x -= e.deltaX;
                viewOffset.y -= e.deltaY;
                render();
                if (wheelSaveTimer) {
                    clearTimeout(wheelSaveTimer);
                }
                wheelSaveTimer = setTimeout(() => {
                    saveViewOffset();
                    showSaveIndicator();
                    wheelSaveTimer = null;
                }, 500);
            }, { passive: false });


            // --- NEW/MODIFIED: Custom Cursor Logic ---
            
            // REMOVED: The updateCursorColor function
            
            // MODIFIED: This function now handles position AND visibility
            document.addEventListener('mousemove', (e) => {
                // 1. Move both cursors regardless of target
                customCursorCircle.style.left = `${e.clientX}px`;
                customCursorCircle.style.top = `${e.clientY}px`;
                customCursorEraser.style.left = `${e.clientX}px`;
                customCursorEraser.style.top = `${e.clientY}px`;

                // 2. Check if mouse is over the canvas
                if (e.target === canvas) {
                    // 3. Show the correct cursor based on the tool
                    if (currentTool === 'eraser') {
                        customCursorCircle.style.display = 'none';
                        customCursorEraser.style.display = 'block';
                    } else if (currentTool !== 'pan') { // Pen, shapes
                        customCursorCircle.style.display = 'block';
                        customCursorEraser.style.display = 'none';
                    } else { // Pan
                        customCursorCircle.style.display = 'none';
                        customCursorEraser.style.display = 'none';
                    }
                } else {
                    // 4. If mouse is not on canvas (e.g., over toolbar), hide both
                    customCursorCircle.style.display = 'none';
                    customCursorEraser.style.display = 'none';
                }
            });
            
            // REMOVED: canvas.addEventListener('mouseenter', ...)
            
            // REMOVED: canvas.addEventListener('mouseleave', ...)
            
            // --- End Custom Cursor Logic ---


            // --- Initialization ---
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            loadFromStorage();
            
            // Set initial active tool UI
            // This will also call updateActiveToolButton() which hides cursors
            updateActiveToolButton(currentTool); 

            window.addEventListener('resize', resizeCanvas);
        });
    </script>
</body>
</html>
